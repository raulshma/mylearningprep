# Entity Relationships - Advanced Patterns

Master advanced relationship patterns including inheritance, owned entities, and complex configurations.

---

## Section 1: Introduction to Relationships

### Advanced Relationship Concepts

<RelationshipDiagram mode="advanced" initialType="many-to-many" />

### Relationship Fixup

EF Core automatically "fixes up" relationships when entities are tracked:

```csharp
// Add blog to context
var blog = new Blog { Id = 1, Title = "Tech Blog" };
context.Blogs.Add(blog);

// Add post with matching BlogId
var post = new Post { Id = 1, Title = "First Post", BlogId = 1 };
context.Posts.Add(post);

// EF Core automatically sets:
// - post.Blog = blog
// - blog.Posts contains post

Console.WriteLine(post.Blog.Title);  // "Tech Blog"
Console.WriteLine(blog.Posts.Count);  // 1
```

### Disconnected Scenarios

When entities come from outside the context (e.g., API requests):

```csharp
// Post comes from API - not tracked
var postDto = new PostDto { Id = 1, Title = "Updated", BlogId = 2 };

// Option 1: Attach and mark modified
var post = new Post { Id = postDto.Id };
context.Posts.Attach(post);
post.Title = postDto.Title;
post.BlogId = postDto.BlogId;

// Option 2: Use Update (marks all as modified)
var post2 = new Post 
{ 
    Id = postDto.Id, 
    Title = postDto.Title, 
    BlogId = postDto.BlogId 
};
context.Posts.Update(post2);

await context.SaveChangesAsync();
```

<ProgressCheckpoint section="intro-relationships" xpReward={20} />

---

## Section 2: One-to-Many Advanced

## Inheritance Strategies

EF Core supports multiple inheritance mapping strategies:

### Table-Per-Hierarchy (TPH)

<DotnetCodePreview
  title="TPH - Single Table"
  code={`// All types in one table with discriminator
public abstract class Content
{
    public int Id { get; set; }
    public string Title { get; set; }
}

public class BlogPost : Content
{
public string Body { get; set; }
}

public class NewsArticle : Content
{
public string Summary { get; set; }
public DateTime PublishDate { get; set; }
}

// Configuration
modelBuilder.Entity<Content>()
.HasDiscriminator<string>("ContentType")
.HasValue<BlogPost>("blog")
.HasValue<NewsArticle>("news");`}
steps={[
{
lineNumbers: [2, 3, 4, 5, 6],
highlight: "Base class",
explanation: "Abstract base class with shared properties"
},
{
lineNumbers: [20, 21, 22, 23],
highlight: "Discriminator",
explanation: "ContentType column determines the actual type"
}
]}
/>

### Table-Per-Type (TPT)

<DotnetCodePreview
  title="TPT - Separate Tables"
  code={`// Each type gets its own table
modelBuilder.Entity<Content>().ToTable("Contents");
modelBuilder.Entity<BlogPost>().ToTable("BlogPosts");
modelBuilder.Entity<NewsArticle>().ToTable("NewsArticles");

// Or using attribute
[Table("BlogPosts")]
public class BlogPost : Content { }`}
/>

### Table-Per-Concrete-Type (TPC) - EF Core 7+

<DotnetCodePreview
  title="TPC - No Base Table"
  code={`// No table for base class, full tables for concrete types
modelBuilder.Entity<Content>().UseTpcMappingStrategy();

// Each concrete type has ALL columns
// BlogPosts: Id, Title, Body
// NewsArticles: Id, Title, Summary, PublishDate`}
/>

## Owned Entity Types

For value objects that don't have their own identity:

<DotnetCodePreview
  title="Owned Entities"
  code={`public class Order
{
    public int Id { get; set; }
    public Address ShippingAddress { get; set; }
    public Address BillingAddress { get; set; }
}

public class Address // Value object
{
public string Street { get; set; }
public string City { get; set; }
public string PostalCode { get; set; }
}

// Configuration
modelBuilder.Entity<Order>()
.OwnsOne(o => o.ShippingAddress, sa =>
{
sa.Property(a => a.Street).HasColumnName("ShippingStreet");
sa.Property(a => a.City).HasColumnName("ShippingCity");
});

modelBuilder.Entity<Order>()
.OwnsOne(o => o.BillingAddress); // Uses default naming`}
steps={[
{
lineNumbers: [4, 5],
highlight: "Multiple owned instances",
explanation: "Same type owned multiple times with different names"
},
{
lineNumbers: [17, 18, 19, 20, 21, 22],
highlight: "Column customization",
explanation: "Customize column names for clarity"
}
]}
/>

## Self-Referencing Relationships

<DotnetCodePreview
  title="Hierarchical Data"
  code={`public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    
    public int? ManagerId { get; set; }
    public Employee? Manager { get; set; }
    public ICollection<Employee> DirectReports { get; set; } = new List<Employee>();
}

modelBuilder.Entity<Employee>()
.HasOne(e => e.Manager)
.WithMany(e => e.DirectReports)
.HasForeignKey(e => e.ManagerId)
.OnDelete(DeleteBehavior.Restrict);

// Query with hierarchy
var ceo = context.Employees
.Include(e => e.DirectReports)
.ThenInclude(e => e.DirectReports)
.FirstOrDefault(e => e.ManagerId == null);`}
steps={[
{
lineNumbers: [6, 7, 8],
highlight: "Self-reference navigation",
explanation: "Manager points to another Employee"
},
{
lineNumbers: [18, 19, 20, 21],
highlight: "Hierarchical query",
explanation: "Chain ThenInclude for multiple levels"
}
]}
/>

## Shadow Properties

Foreign keys without explicit properties:

<DotnetCodePreview
  title="Shadow Foreign Keys"
  code={`public class Post
{
    public int Id { get; set; }
    public string Title { get; set; }
    // No BlogId property!
    public Blog Blog { get; set; }
}

// EF creates shadow property "BlogId"
modelBuilder.Entity<Post>()
.Property<int>("BlogId");

// Access shadow property
var blogId = context.Entry(post).Property("BlogId").CurrentValue;

// Query using shadow property
var posts = context.Posts
.Where(p => EF.Property<int>(p, "BlogId") == 1)
.ToList();`}
/>

## Table Splitting

Multiple entities sharing one table:

<DotnetCodePreview
  title="Table Splitting"
  code={`public class Order
{
    public int Id { get; set; }
    public string Status { get; set; }
    public OrderDetail Detail { get; set; }
}

public class OrderDetail // Same table!
{
public int Id { get; set; }
public string PaymentMethod { get; set; }
public string ShippingNotes { get; set; }
}

modelBuilder.Entity<Order>()
.HasOne(o => o.Detail)
.WithOne()
.HasForeignKey<OrderDetail>(d => d.Id);

modelBuilder.Entity<Order>().ToTable("Orders");
modelBuilder.Entity<OrderDetail>().ToTable("Orders"); // Same table!`}
/>

<ProgressCheckpoint section="one-to-many" xpReward={20} />

---

## Section 3: Many-to-Many Advanced

### Configuring Skip Navigations

```csharp
modelBuilder.Entity<Student>()
    .HasMany(s => s.Courses)
    .WithMany(c => c.Students)
    .UsingEntity<Dictionary<string, object>>(
        "StudentCourse",
        j => j.HasOne<Course>().WithMany().HasForeignKey("CourseId"),
        j => j.HasOne<Student>().WithMany().HasForeignKey("StudentId"),
        j =>
        {
            j.HasKey("StudentId", "CourseId");
            j.ToTable("StudentCourses");
            j.HasIndex("CourseId");
        });
```

### Many-to-Many with Composite Keys

```csharp
public class ProductCategory
{
    public int ProductId { get; set; }
    public Product Product { get; set; } = null!;
    
    public int CategoryId { get; set; }
    public Category Category { get; set; } = null!;
    
    public int DisplayOrder { get; set; }
    public bool IsPrimary { get; set; }
}

modelBuilder.Entity<ProductCategory>()
    .HasKey(pc => new { pc.ProductId, pc.CategoryId });

modelBuilder.Entity<ProductCategory>()
    .HasOne(pc => pc.Product)
    .WithMany(p => p.ProductCategories)
    .HasForeignKey(pc => pc.ProductId);

modelBuilder.Entity<ProductCategory>()
    .HasOne(pc => pc.Category)
    .WithMany(c => c.ProductCategories)
    .HasForeignKey(pc => pc.CategoryId);
```

### Querying Complex Many-to-Many

```csharp
// Get products with their primary category
var productsWithPrimaryCategory = await context.Products
    .Select(p => new
    {
        Product = p,
        PrimaryCategory = p.ProductCategories
            .Where(pc => pc.IsPrimary)
            .Select(pc => pc.Category)
            .FirstOrDefault()
    })
    .ToListAsync();

// Get categories with product count
var categoriesWithCount = await context.Categories
    .Select(c => new
    {
        Category = c,
        ProductCount = c.ProductCategories.Count,
        Products = c.ProductCategories
            .OrderBy(pc => pc.DisplayOrder)
            .Select(pc => pc.Product)
            .ToList()
    })
    .ToListAsync();
```

### Temporal Relationships

Track relationship history with temporal tables:

```csharp
modelBuilder.Entity<Enrollment>(entity =>
{
    entity.ToTable("Enrollments", tb => tb.IsTemporal(ttb =>
    {
        ttb.HasPeriodStart("ValidFrom");
        ttb.HasPeriodEnd("ValidTo");
        ttb.UseHistoryTable("EnrollmentsHistory");
    }));
});

// Query historical enrollments
var historicalEnrollments = await context.Enrollments
    .TemporalAsOf(DateTime.UtcNow.AddYears(-1))
    .Where(e => e.StudentId == 1)
    .ToListAsync();
```

## Key Takeaways

- **TPH** is default and most performant for simple hierarchies
- **TPT/TPC** provide better normalization at query cost
- **Owned entities** for value objects without identity
- **Self-referencing** for hierarchical/tree structures
- **Shadow properties** when you don't need FK in the model
- **Table splitting** for loading subsets of wide tables
- **Relationship fixup** happens automatically for tracked entities
- **Disconnected scenarios** require explicit Attach/Update
- **Temporal tables** can track relationship history

<ProgressCheckpoint section="many-to-many" xpReward={20} />
