# DbContext & DbSet - Practical Patterns

DbContext is the foundation of Entity Framework Core - understanding how it works under the hood will help you write more efficient data access code.

---

## Section 1: Introduction to DbContext

### DbContext Lifecycle

Understanding when and how to create/dispose DbContext:

```csharp
// BAD: Long-lived context (memory leaks, stale data)
public class MyService
{
    private readonly BloggingContext _context = new BloggingContext();
    // This context lives for the entire service lifetime!
}

// GOOD: Short-lived context with using
public class MyService
{
    public void DoWork()
    {
        using var context = new BloggingContext();
        // Context is disposed when method ends
    }
}

// BEST: Dependency injection (scoped lifetime)
public class MyService
{
    private readonly BloggingContext _context;
    
    public MyService(BloggingContext context)
    {
        _context = context;  // DI container manages lifetime
    }
}
```

### Connection Management

```csharp
// DbContext manages connections automatically
using var context = new BloggingContext();

// Connection opens on first query
var blogs = context.Blogs.ToList();  // Opens connection

// Connection closes after query completes
// Multiple queries reuse the same connection

var posts = context.Posts.ToList();  // Reuses connection

// Connection closes when context is disposed
```

<ProgressCheckpoint section="intro-dbcontext" xpReward={13} />

---

## Section 2: DbSet Basics

## DbContext Configuration

Every DbContext needs to know how to connect to the database. You can configure this in multiple ways:

<DotnetCodePreview
  title="DbContext with Configuration"
  code={`public class BloggingContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }
    public DbSet<Post> Posts { get; set; }

    protected override void OnConfiguring(
        DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            "Server=.;Database=Blogging;Trusted_Connection=True");
    }

}`}
steps={[
{
lineNumbers: [3, 4],
highlight: "Entity Sets",
explanation: "Each DbSet represents a table and allows querying/manipulating that entity type"
},
{
lineNumbers: [6, 7, 8, 9, 10, 11],
highlight: "Configuration",
explanation: "OnConfiguring sets up the database provider and connection string"
}
]}
/>

## Dependency Injection Pattern

In real applications, you'll typically inject DbContext using the DI container:

<DotnetCodePreview
  title="DbContext with DI"
  code={`// In Program.cs
builder.Services.AddDbContext<BloggingContext>(options =>
    options.UseSqlServer(connectionString));

// In your service
public class BlogService
{
private readonly BloggingContext \_context;

    public BlogService(BloggingContext context)
    {
        _context = context;
    }

    public async Task<List<Blog>> GetAllBlogsAsync()
    {
        return await _context.Blogs.ToListAsync();
    }

}`}
steps={[
{
lineNumbers: [2, 3],
highlight: "Register with DI",
explanation: "AddDbContext registers the context for dependency injection"
},
{
lineNumbers: [10, 11, 12, 13],
highlight: "Constructor injection",
explanation: "The context is automatically injected when the service is created"
},
{
lineNumbers: [15, 16, 17, 18],
highlight: "Using the context",
explanation: "Access DbSet properties to query the database"
}
]}
/>

## Change Tracking in Action

<DbContextVisualizer mode="intermediate" />

## Understanding Entity States

The change tracker assigns a state to each entity:

| State         | Description                  | What SaveChanges Does |
| :------------ | :--------------------------- | :-------------------- |
| **Added**     | New entity, not in database  | INSERT                |
| **Modified**  | Existing entity with changes | UPDATE                |
| **Deleted**   | Marked for removal           | DELETE                |
| **Unchanged** | No changes from database     | Nothing               |
| **Detached**  | Not tracked by context       | Nothing               |

<DotnetCodePreview
  title="Working with Entity States"
  code={`// Adding a new entity
context.Blogs.Add(new Blog { Title = "New" });
// State: Added

// Modifying an existing entity
var blog = context.Blogs.Find(1);
blog.Title = "Updated Title";
// State: Modified

// Deleting an entity
context.Blogs.Remove(blog);
// State: Deleted

// Check entity state
var entry = context.Entry(blog);
Console.WriteLine(entry.State);`}
steps={[
{
lineNumbers: [2, 3],
highlight: "Adding",
explanation: "Add() marks the entity as Added"
},
{
lineNumbers: [6, 7, 8],
highlight: "Modifying",
explanation: "Changing properties of a tracked entity sets it to Modified"
},
{
lineNumbers: [11, 12],
highlight: "Deleting",
explanation: "Remove() marks the entity for deletion"
}
]}
/>

## Best Practices

1. **Use `using` or DI**: Always dispose of your DbContext properly
2. **Keep DbContext short-lived**: Don't hold onto contexts for long periods
3. **One DbContext per request**: In web apps, use scoped lifetime
4. **Use async methods**: Prefer `ToListAsync()`, `FirstOrDefaultAsync()`, etc.

<ProgressCheckpoint section="dbset-basics" xpReward={13} />

---

## Section 3: SaveChanges

### SaveChanges Internals

What happens when you call SaveChanges():

1. **Detect Changes** - Scans tracked entities for modifications
2. **Validate** - Checks constraints and validation rules
3. **Generate SQL** - Creates INSERT/UPDATE/DELETE statements
4. **Execute** - Sends commands to database in a transaction
5. **Update State** - Marks entities as Unchanged

```csharp
// Manual change detection
context.ChangeTracker.DetectChanges();

// Disable automatic detection for performance
context.ChangeTracker.AutoDetectChangesEnabled = false;

// Make changes
context.Blogs.Add(new Blog { Title = "Test" });

// Manually detect before save
context.ChangeTracker.DetectChanges();
await context.SaveChangesAsync();

// Re-enable
context.ChangeTracker.AutoDetectChangesEnabled = true;
```

### Transaction Handling

```csharp
// SaveChanges uses implicit transaction
await context.SaveChangesAsync();  // All or nothing

// Explicit transaction for multiple SaveChanges
using var transaction = await context.Database.BeginTransactionAsync();

try
{
    context.Blogs.Add(new Blog { Title = "Blog 1" });
    await context.SaveChangesAsync();
    
    context.Posts.Add(new Post { Title = "Post 1", BlogId = 1 });
    await context.SaveChangesAsync();
    
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

### Handling Concurrency

```csharp
try
{
    await context.SaveChangesAsync();
}
catch (DbUpdateConcurrencyException ex)
{
    foreach (var entry in ex.Entries)
    {
        var databaseValues = await entry.GetDatabaseValuesAsync();
        
        if (databaseValues == null)
        {
            // Entity was deleted
            Console.WriteLine("Entity was deleted by another user");
        }
        else
        {
            // Entity was modified
            entry.OriginalValues.SetValues(databaseValues);
            // Retry or merge changes
        }
    }
}
```

### Bulk Operations

```csharp
// Adding many entities
var blogs = Enumerable.Range(1, 1000)
    .Select(i => new Blog { Title = $"Blog {i}" })
    .ToList();

context.Blogs.AddRange(blogs);  // More efficient than Add() in loop
await context.SaveChangesAsync();

// Removing many entities
var blogsToDelete = await context.Blogs
    .Where(b => b.Title.StartsWith("Old"))
    .ToListAsync();

context.Blogs.RemoveRange(blogsToDelete);
await context.SaveChangesAsync();
```

<ProgressCheckpoint section="savechanges" xpReward={14} />
