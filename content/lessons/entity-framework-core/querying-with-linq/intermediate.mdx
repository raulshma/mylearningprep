# Querying Data with LINQ - Practical Patterns

Master the practical aspects of LINQ with EF Core - from projections to eager loading and complex filtering.

---

## Section 1: Introduction to LINQ

### Query Execution Model

Understanding when queries execute:

```csharp
// Query is NOT executed yet (deferred execution)
var query = context.Blogs.Where(b => b.Rating > 3);

// Query executes NOW (materialization)
var results = query.ToList();

// These also trigger execution:
var first = query.FirstOrDefault();  // Executes
var count = query.Count();           // Executes
var any = query.Any();               // Executes

// Chaining doesn't execute
var refined = query
    .OrderBy(b => b.Title)
    .Take(10);  // Still not executed!

var final = refined.ToList();  // NOW it executes
```

### IQueryable vs IEnumerable

```csharp
// IQueryable - query runs on database
IQueryable<Blog> dbQuery = context.Blogs
    .Where(b => b.Rating > 3);  // SQL: WHERE Rating > 3

// IEnumerable - filtering happens in memory
IEnumerable<Blog> memoryQuery = context.Blogs
    .ToList()  // Fetches ALL blogs
    .Where(b => b.Rating > 3);  // Filters in C#

// Always prefer IQueryable for database filtering!
```

<ProgressCheckpoint section="intro-linq" xpReward={13} />

---

## Section 2: Projections

## Complex Filtering

<EntityFrameworkVisualizer mode="intermediate" />

<DotnetCodePreview
  title="Advanced Filtering"
  code={`// Multiple conditions
var filteredBlogs = context.Blogs
    .Where(b => b.Rating > 3 && b.IsPublished)
    .Where(b => b.CreatedDate > DateTime.Now.AddMonths(-6))
    .ToList();

// OR conditions
var popularOrNew = context.Blogs
.Where(b => b.Rating > 4 || b.CreatedDate > DateTime.Now.AddDays(-7))
.ToList();

// Using Contains (IN clause)
var ids = new[] { 1, 2, 3 };
var specificBlogs = context.Blogs
.Where(b => ids.Contains(b.Id))
.ToList();`}
steps={[
{
lineNumbers: [3, 4],
highlight: "Chained Where",
explanation: "Multiple Where clauses are combined with AND"
},
{
lineNumbers: [9],
highlight: "OR conditions",
explanation: "Use || for OR logic within a single Where"
},
{
lineNumbers: [14, 15],
highlight: "Contains = IN",
explanation: "Contains translates to SQL IN clause"
}
]}
/>

## Projections with Select

Don't load entire entities when you only need a few fields:

<DotnetCodePreview
  title="Projecting Data"
  code={`// Select only what you need
var titles = context.Blogs
    .Select(b => b.Title)
    .ToList();

// Project to anonymous type
var blogInfo = context.Blogs
.Select(b => new { b.Title, b.Url, PostCount = b.Posts.Count() })
.ToList();

// Project to DTO
var dtos = context.Blogs
.Select(b => new BlogDto
{
Title = b.Title,
Url = b.Url,
Author = b.Author.Name
})
.ToList();`}
steps={[
{
lineNumbers: [2, 3, 4],
highlight: "Simple projection",
explanation: "Only the Title column is fetched from database"
},
{
lineNumbers: [7, 8, 9],
highlight: "Anonymous type",
explanation: "Create on-the-fly objects with just the fields you need"
},
{
lineNumbers: [12, 13, 14, 15, 16, 17, 18, 19],
highlight: "DTO projection",
explanation: "Map directly to your DTOs for cleaner code"
}
]}
/>

## Eager Loading with Include

Avoid the N+1 problem by loading related data upfront:

<DotnetCodePreview
  title="Include Related Data"
  code={`// Include posts with blogs
var blogsWithPosts = context.Blogs
    .Include(b => b.Posts)
    .ToList();

// Include nested relationships
var blogsWithComments = context.Blogs
.Include(b => b.Posts)
.ThenInclude(p => p.Comments)
.ToList();

// Multiple includes
var fullData = context.Blogs
.Include(b => b.Posts)
.Include(b => b.Author)
.ToList();

// Filtered include (EF Core 5+)
var recentPosts = context.Blogs
.Include(b => b.Posts.Where(p => p.CreatedDate > DateTime.Now.AddDays(-30)))
.ToList();`}
steps={[
{
lineNumbers: [3],
highlight: "Basic Include",
explanation: "Include() uses a JOIN to load related Posts"
},
{
lineNumbers: [8, 9],
highlight: "ThenInclude",
explanation: "Chain ThenInclude for nested relationships"
},
{
lineNumbers: [19],
highlight: "Filtered Include",
explanation: "Apply conditions to included collections"
}
]}
/>

## Pagination

<DotnetCodePreview
  title="Skip and Take"
  code={`int pageNumber = 2;
int pageSize = 10;

var pagedBlogs = context.Blogs
.OrderBy(b => b.CreatedDate)
.Skip((pageNumber - 1) \* pageSize)
.Take(pageSize)
.ToList();

// Get total count for pagination UI
var totalCount = context.Blogs.Count();
var totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);`}
steps={[
{
lineNumbers: [5],
highlight: "Always order first",
explanation: "Paging without ordering leads to inconsistent results"
},
{
lineNumbers: [6],
highlight: "Skip",
explanation: "Skip past previous pages"
},
{
lineNumbers: [7],
highlight: "Take",
explanation: "Take only the current page's items"
}
]}
/>

## Grouping and Aggregation

<DotnetCodePreview
  title="GroupBy and Aggregates"
  code={`// Group posts by blog
var postsByBlog = context.Posts
    .GroupBy(p => p.BlogId)
    .Select(g => new
    {
        BlogId = g.Key,
        PostCount = g.Count(),
        AvgRating = g.Average(p => p.Rating)
    })
    .ToList();

// Simple aggregates
var stats = new
{
TotalBlogs = context.Blogs.Count(),
AvgRating = context.Blogs.Average(b => b.Rating),
MaxRating = context.Blogs.Max(b => b.Rating)
};`}
/>

## Best Practices

1. **Use projections** - Select only needed columns
2. **Order before paging** - Always use OrderBy with Skip/Take
3. **Use Include wisely** - Only include what you'll use
4. **Avoid client evaluation** - Keep queries server-side
5. **Check generated SQL** - Use ToQueryString() to verify

<ProgressCheckpoint section="projections" xpReward={14} />

---

## Section 3: Eager Loading

### Loading Strategies Compared

| Strategy | When Loaded | Use Case |
|:---------|:-----------|:---------|
| **Eager** (Include) | With main query | Know you need related data |
| **Explicit** (Load) | On demand | Conditional loading |
| **Lazy** (proxies) | On access | Simple scenarios (careful!) |

### Explicit Loading

```csharp
// Load blog first
var blog = context.Blogs.Find(1);

// Later, explicitly load posts
context.Entry(blog)
    .Collection(b => b.Posts)
    .Load();

// Load with filtering
context.Entry(blog)
    .Collection(b => b.Posts)
    .Query()
    .Where(p => p.IsPublished)
    .Load();

// Load reference (single entity)
context.Entry(blog)
    .Reference(b => b.Author)
    .Load();
```

### Avoiding N+1 Problem

```csharp
// BAD: N+1 queries (1 for blogs + N for posts)
var blogs = context.Blogs.ToList();
foreach (var blog in blogs)
{
    // Each iteration triggers a new query!
    Console.WriteLine(blog.Posts.Count);
}

// GOOD: Single query with Include
var blogsWithPosts = context.Blogs
    .Include(b => b.Posts)
    .ToList();
foreach (var blog in blogsWithPosts)
{
    // Posts already loaded - no extra queries
    Console.WriteLine(blog.Posts.Count);
}
```

### Filtered Includes (EF Core 5+)

```csharp
// Only include recent posts
var blogs = context.Blogs
    .Include(b => b.Posts.Where(p => p.CreatedDate > DateTime.Now.AddDays(-30)))
    .ToList();

// Include with ordering
var blogsOrdered = context.Blogs
    .Include(b => b.Posts.OrderByDescending(p => p.CreatedDate).Take(5))
    .ToList();
```

<ProgressCheckpoint section="eager-loading" xpReward={13} />
