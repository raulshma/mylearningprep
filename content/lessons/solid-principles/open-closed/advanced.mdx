# Open/Closed Principle (OCP) ‚Äî Advanced

At the advanced level, we explore OCP in enterprise contexts: **plugin architectures**, **reflection-based extensions**, **middleware pipelines**, and the trade-offs of premature abstraction.

## OCP in ASP.NET Core Architecture

ASP.NET Core itself is a masterclass in OCP. The framework is **closed** to modification but **open** to extension through:

| Extension Point | What You Can Add |
|:----------------|:-----------------|
| **Middleware** | Request/response processing |
| **Services** | Custom implementations via DI |
| **Filters** | Action/result/exception handling |
| **Model Binders** | Custom parameter binding |
| **Tag Helpers** | Custom Razor HTML helpers |

<InfoBox type="important">
**Framework Insight:** When designing APIs or frameworks, study ASP.NET Core's extension patterns. They demonstrate OCP at scale.
</InfoBox>

## Case Study: Building a Plugin System

Let's build a file processing system that supports unlimited file formats without modification:

<DotnetCodePreview
  title="Plugin Architecture: File Processors"
  code={`// 1. Define the extension point (abstraction)
public interface IFileProcessor
{
    string[] SupportedExtensions { get; }
    Task<ProcessingResult> ProcessAsync(
        Stream fileStream, 
        ProcessingOptions options);
}

// 2. Create a registry (closed to modification)
public class FileProcessorRegistry
{
    private readonly IEnumerable<IFileProcessor> _processors;
    
    public FileProcessorRegistry(IEnumerable<IFileProcessor> processors)
    {
        _processors = processors;
    }
    
    public IFileProcessor? GetProcessor(string extension)
    {
        return _processors.FirstOrDefault(p => 
            p.SupportedExtensions.Contains(extension, 
                StringComparer.OrdinalIgnoreCase));
    }
}

// 3. Implement processors (open for extension)
public class PdfProcessor : IFileProcessor
{
    public string[] SupportedExtensions => new[] { ".pdf" };
    
    public async Task<ProcessingResult> ProcessAsync(
        Stream fileStream, ProcessingOptions options)
    {
        // PDF-specific processing
        using var document = PdfDocument.Load(fileStream);
        return new ProcessingResult 
        { 
            PageCount = document.PageCount,
            TextContent = await document.ExtractTextAsync()
        };
    }
}

// Adding DOCX support = new class, zero changes elsewhere!
public class DocxProcessor : IFileProcessor
{
    public string[] SupportedExtensions => new[] { ".docx", ".doc" };
    
    public async Task<ProcessingResult> ProcessAsync(
        Stream fileStream, ProcessingOptions options)
    {
        using var doc = new WordDocument(fileStream);
        return new ProcessingResult 
        { 
            PageCount = doc.Sections.Count,
            TextContent = doc.GetText()
        };
    }
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7, 8],
      highlight: "Extension Point",
      explanation: "Interface is the contract - never changes once published"
    },
    {
      lineNumbers: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],
      highlight: "Registry (Closed)",
      explanation: "Core logic never changes - just discovers registered processors"
    },
    {
      lineNumbers: [43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55],
      highlight: "New Extension",
      explanation: "Adding DOCX = implement interface, register via DI. Zero modification!"
    }
  ]}
/>

### Auto-Registration with Reflection

Use assembly scanning to automatically discover and register plugins:

```csharp
// Program.cs - Auto-register all processors
services.Scan(scan => scan
    .FromAssembliesOf(typeof(IFileProcessor))
    .AddClasses(classes => classes.AssignableTo<IFileProcessor>())
    .AsImplementedInterfaces()
    .WithScopedLifetime());

// Or manually with reflection
var processorTypes = AppDomain.CurrentDomain.GetAssemblies()
    .SelectMany(a => a.GetTypes())
    .Where(t => typeof(IFileProcessor).IsAssignableFrom(t) && !t.IsAbstract);

foreach (var type in processorTypes)
{
    services.AddScoped(typeof(IFileProcessor), type);
}
```

### External Plugin Loading

For true plugin architecture, load from external assemblies:

```csharp
public class PluginLoader
{
    public IEnumerable<IFileProcessor> LoadPlugins(string pluginDirectory)
    {
        var pluginPaths = Directory.GetFiles(pluginDirectory, "*.dll");
        
        foreach (var path in pluginPaths)
        {
            var assembly = Assembly.LoadFrom(path);
            var processorTypes = assembly.GetTypes()
                .Where(t => typeof(IFileProcessor).IsAssignableFrom(t))
                .Where(t => !t.IsAbstract);
                
            foreach (var type in processorTypes)
            {
                yield return (IFileProcessor)Activator.CreateInstance(type)!;
            }
        }
    }
}
```

<SolidPrincipleDemo principle="O" mode="advanced" />

## OCP in Middleware Pipelines

ASP.NET Core's middleware is a perfect OCP example:

```csharp
// Middleware: Open for extension
public class LoggingMiddleware
{
    private readonly RequestDelegate _next;
    
    public LoggingMiddleware(RequestDelegate next) => _next = next;
    
    public async Task InvokeAsync(HttpContext context)
    {
        Log($"Request: {context.Request.Path}");
        await _next(context);
        Log($"Response: {context.Response.StatusCode}");
    }
}

// Application: Closed to modification, open to new middleware
app.UseMiddleware<LoggingMiddleware>();  // Add without changing app
app.UseMiddleware<AuthenticationMiddleware>();
app.UseMiddleware<RateLimitingMiddleware>();  // Just add more!
```

### Building Custom Pipelines

Apply the same pattern to your domain:

```csharp
// Pipeline for order validation
public interface IOrderValidator
{
    int Order { get; }  // Execution order
    Task<ValidationResult> ValidateAsync(Order order);
}

public class OrderValidationPipeline
{
    private readonly IEnumerable<IOrderValidator> _validators;
    
    public async Task<ValidationResult> ValidateAsync(Order order)
    {
        var results = new List<ValidationResult>();
        
        foreach (var validator in _validators.OrderBy(v => v.Order))
        {
            var result = await validator.ValidateAsync(order);
            results.Add(result);
            
            if (!result.IsValid) break;  // Short-circuit on failure
        }
        
        return ValidationResult.Combine(results);
    }
}

// Add validators without touching the pipeline
public class InventoryValidator : IOrderValidator { /* ... */ }
public class PaymentValidator : IOrderValidator { /* ... */ }
public class FraudValidator : IOrderValidator { /* new! */ }
```

## Trade-offs: When OCP Goes Wrong

### The Premature Abstraction Anti-Pattern

OCP requires **predicting** where extensions will occur. Predict wrong and you get:

```csharp
// Over-engineered: Created interfaces nobody ever implemented
public interface IStringFormatter { }
public interface IStringParserFactory { }
public interface IStringParserFactoryFactory { }  // Really?

// YAGNI: You Aren't Gonna Need It
public class SimpleFormatter
{
    public string Format(string input) => input.Trim().ToLower();
    // Just this. No interface. No factory. Done.
}
```

<InfoBox type="warning">
**YAGNI Warning:** Don't create abstractions "just in case." Wait for the *second* use case before abstracting. First time = concrete, second time = refactor to abstract.
</InfoBox>

### When to Apply OCP

| Apply OCP | Don't Apply OCP |
|:----------|:----------------|
| Known variation points | Truly one-off code |
| Framework/library code | Internal utilities |
| Payment processors, file formats | Simple CRUD operations |
| Algorithm variations | Stable domain logic |

## Advanced Patterns

### Specification Pattern

Compose complex business rules without modification:

```csharp
public interface ISpecification<T>
{
    bool IsSatisfiedBy(T entity);
}

public class AndSpecification<T> : ISpecification<T>
{
    private readonly ISpecification<T> _left, _right;
    
    public bool IsSatisfiedBy(T entity) 
        => _left.IsSatisfiedBy(entity) && _right.IsSatisfiedBy(entity);
}

// Usage: Compose rules without modifying any class
var premiumRule = new IsPremiumCustomer();
var highValueRule = new HasMinimumOrderValue(1000m);
var targetCustomer = new AndSpecification(premiumRule, highValueRule);
```

### Chain of Responsibility

Each handler decides whether to process or pass along:

```csharp
public abstract class Handler<T>
{
    protected Handler<T>? _next;
    
    public void SetNext(Handler<T> next) => _next = next;
    
    public virtual void Handle(T request)
    {
        _next?.Handle(request);
    }
}

// Add handlers without modifying the chain
public class AuthHandler : Handler<Request> { /* ... */ }
public class ValidationHandler : Handler<Request> { /* ... */ }
public class LoggingHandler : Handler<Request> { /* new! */ }
```

## Measuring OCP Compliance

| Metric | Indicates OCP Violation |
|:-------|:-----------------------|
| **Shotgun Surgery** | One change ‚Üí Many files modified |
| **Switch Statement Smell** | Switch/if-else on type |
| **Modification Frequency** | Same files changed repeatedly |
| **Test Fragility** | Unrelated tests break |

## Key Takeaways

- üîå **Plugin architecture** is the ultimate OCP expression
- üîç **Reflection** enables runtime extension discovery
- üöÄ **Middleware patterns** compose behaviors elegantly
- ‚öñÔ∏è **YAGNI balance** is crucial ‚Äî don't over-abstract early
- üìä **Measure** with modification frequency and test fragility

<ProgressCheckpoint section="ocp-application" xpReward={60} />
