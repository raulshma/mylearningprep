# Interface Segregation Principle (ISP) â€” Advanced

At the advanced level, we explore ISP in the context of **microservices API design**, **CQRS patterns**, **interface composition**, and the relationship between ISP and other architectural patterns.

## ISP and Microservices Contracts

In microservices, ISP applies to **service contracts** (APIs). Fat APIs lead to tight coupling:

<DotnetCodePreview
  title="API-Level ISP: Service Contracts"
  code={`// âŒ Fat API Contract - all clients get everything
public interface IOrderService
{
    // Customer operations
    Task<Order> CreateOrder(CreateOrderRequest req);
    Task<Order> GetOrder(Guid orderId);
    Task<OrderStatus> GetOrderStatus(Guid orderId);
    
    // Admin operations
    Task<IEnumerable<Order>> GetAllOrders(DateRange range);
    Task UpdateOrderStatus(Guid orderId, OrderStatus status);
    Task RefundOrder(Guid orderId);
    
    // Analytics operations
    Task<OrderMetrics> GetDailyMetrics(DateTime date);
    Task<RevenueReport> GenerateRevenueReport(DateRange range);
    
    // Fulfillment operations
    Task<ShippingLabel> GenerateShippingLabel(Guid orderId);
    Task MarkAsShipped(Guid orderId, string trackingNumber);
}

// Customer mobile app ONLY needs:
// - CreateOrder, GetOrder, GetOrderStatus
// But it's coupled to the ENTIRE interface!

// âœ… Segregated Contracts (Backend-for-Frontend pattern)
public interface ICustomerOrderApi
{
    Task<Order> CreateOrder(CreateOrderRequest req);
    Task<Order> GetOrder(Guid orderId);
    Task<OrderStatus> GetOrderStatus(Guid orderId);
}

public interface IAdminOrderApi
{
    Task<IEnumerable<Order>> GetAllOrders(DateRange range);
    Task UpdateOrderStatus(Guid orderId, OrderStatus status);
    Task RefundOrder(Guid orderId);
}

public interface IFulfillmentOrderApi
{
    Task<ShippingLabel> GenerateShippingLabel(Guid orderId);
    Task MarkAsShipped(Guid orderId, string trackingNumber);
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7, 8],
      highlight: "Fat API",
      explanation: "Single interface for ALL clients - causes tight coupling"
    },
    {
      lineNumbers: [26, 27, 28, 29, 30, 31],
      highlight: "Customer API",
      explanation: "Mobile app only gets what it needs - decoupled!"
    },
    {
      lineNumbers: [33, 34, 35, 36, 37, 38],
      highlight: "Admin API",
      explanation: "Admin portal has its own focused contract"
    }
  ]}
/>

<InfoBox type="important">
**BFF Pattern:** Backend-for-Frontend is ISP at the architecture level. Each client type gets a tailored API instead of a one-size-fits-all contract.
</InfoBox>

## CQRS: ISP for Read/Write

Command Query Responsibility Segregation is ISP applied to data access:

```csharp
// Traditional "fat" repository interface
public interface IRepository<T>
{
    T GetById(int id);
    IEnumerable<T> GetAll();
    IQueryable<T> Query();
    void Add(T entity);
    void Update(T entity);
    void Delete(int id);
    void SaveChanges();
}

// CQRS: Segregated Read and Write
public interface IReader<T>
{
    T GetById(int id);
    IEnumerable<T> GetAll();
    IQueryable<T> Query();
}

public interface IWriter<T>
{
    void Add(T entity);
    void Update(T entity);
    void Delete(int id);
}

// Query handlers only need read access
public class OrderQueryHandler
{
    private readonly IReader<Order> _reader;
    
    public OrderQueryHandler(IReader<Order> reader) => _reader = reader;
    
    public Order Handle(GetOrderQuery query) 
        => _reader.GetById(query.OrderId);
}

// Command handlers only need write access
public class CreateOrderHandler
{
    private readonly IWriter<Order> _writer;
    
    public CreateOrderHandler(IWriter<Order> writer) => _writer = writer;
    
    public void Handle(CreateOrderCommand cmd)
    {
        var order = new Order(cmd.CustomerId, cmd.Items);
        _writer.Add(order);
    }
}
```

<SolidPrincipleDemo principle="I" mode="advanced" />

## Interface Composition Patterns

### Marker Interfaces

Empty interfaces used for tagging capabilities:

```csharp
// Marker interfaces - contain no methods
public interface IAuditable { }
public interface ISoftDeletable { }
public interface ICacheable { }

// Entity can be composed with capabilities
public class Order : IAuditable, ISoftDeletable
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? DeletedAt { get; set; }
}

// Generic constraint using marker
public class AuditMiddleware<T> where T : IAuditable
{
    public void OnSave(T entity) => entity.AuditFields.Updated = DateTime.UtcNow;
}
```

### Mixin-Style Interfaces with Default Implementation (C# 8+)

```csharp
public interface ITimestamped
{
    DateTime CreatedAt { get; set; }
    DateTime UpdatedAt { get; set; }
    
    // Default implementation (C# 8+)
    void Touch() => UpdatedAt = DateTime.UtcNow;
}

public interface ISoftDeletable
{
    DateTime? DeletedAt { get; set; }
    bool IsDeleted => DeletedAt.HasValue;
    
    void SoftDelete() => DeletedAt = DateTime.UtcNow;
    void Restore() => DeletedAt = null;
}

// Compose behaviors without inheritance hierarchy
public class Product : ITimestamped, ISoftDeletable
{
    public int Id { get; set; }
    public string Name { get; set; }
    
    // Interface implementations
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public DateTime? DeletedAt { get; set; }
    
    // Gets Touch(), SoftDelete(), Restore() for free!
}
```

## ISP and Dependency Injection

ISP enables precise dependency graphs:

```csharp
// Without ISP: Controller depends on HUGE service
public class OrderController
{
    private readonly IOrderService _service;  // 20+ methods we don't use!
    
    public OrderController(IOrderService service) => _service = service;
}

// With ISP: Controller depends on exactly what it needs
public class OrderController
{
    private readonly IOrderQuerier _querier;
    private readonly IOrderCommander _commander;
    
    public OrderController(IOrderQuerier querier, IOrderCommander commander)
    {
        _querier = querier;
        _commander = commander;
    }
    
    [HttpGet("{id}")]
    public Order Get(int id) => _querier.GetById(id);
    
    [HttpPost]
    public void Create(Order order) => _commander.Create(order);
}
```

### Testing Benefits

```csharp
// Without ISP: Must mock 20+ methods
var mockService = new Mock<IOrderService>();
mockService.Setup(s => s.GetById(It.IsAny<int>())).Returns(testOrder);
// Ignore the other 19 methods...

// With ISP: Mock only what's used
var mockQuerier = new Mock<IOrderQuerier>();
mockQuerier.Setup(q => q.GetById(It.IsAny<int>())).Returns(testOrder);
// That's it!
```

## Architecture Patterns Enabled by ISP

| Pattern | How ISP Helps |
|:--------|:--------------|
| **CQRS** | Separate read/write interfaces |
| **BFF** | Client-specific API surfaces |
| **Microservices** | Bounded context contracts |
| **Clean Architecture** | Use case-specific ports |
| **Event-Driven** | Focused event handlers |

## Detecting ISP Violations

### Static Analysis Rules

```csharp
// NDepend query for ISP violations
from t in Types
where t.IsInterface
let methods = t.Methods.Where(m => !m.IsConstructor)
let avgUsage = methods.Average(m => 
    m.MethodsCallingMe.Count() / (double)t.TypesImplementingMe.Count)
where avgUsage < 0.5  // Methods used by less than 50% of implementers
select new { t, avgUsage, methods.Count() }
```

### Metrics

| Metric | Threshold | Indicates |
|:-------|:----------|:----------|
| Methods per interface | > 5-7 | May need splitting |
| Implementer method usage | < 80% | Unused methods = ISP smell |
| Interface fan-out | High | Too many dependents |

## Trade-offs

### When Many Small Interfaces Hurt

| Scenario | Problem |
|:---------|:--------|
| **Extreme fragmentation** | `IHasId`, `IHasName`, `IHasPrice` - too granular |
| **Loss of cohesion** | Splitting naturally cohesive concepts |
| **Cognitive overload** | 50 interfaces harder than 5 |

### Finding Balance

```csharp
// Too granular - overkill
interface IHasId { int Id { get; } }
interface IHasName { string Name { get; } }
interface IHasPrice { decimal Price { get; } }

// Better - cohesive grouping
interface IProduct
{
    int Id { get; }
    string Name { get; }
    decimal Price { get; }
}

interface IDiscountable
{
    decimal ApplyDiscount(decimal percentage);
}
```

## Key Takeaways

- ðŸŒ **API-level ISP** applies to microservice contracts
- ðŸ“– **CQRS** is ISP for data access (read/write separation)
- ðŸ§© **Composition** via multiple small interfaces
- ðŸ’‰ **DI benefits** from precise, focused dependencies
- ðŸ“Š **Measure** with usage ratios and method counts
- âš–ï¸ **Balance** granularity vs. cognitive load

<ProgressCheckpoint section="isp-application" xpReward={60} />
