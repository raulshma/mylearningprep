# Interface Segregation Principle (ISP)

Have you ever used a TV remote with 100 buttons, when you only use 5 of them? Volume up, volume down, channel change, mute, and power. That's it! ğŸ“º

**The Interface Segregation Principle is about giving people ONLY what they need.**

## The Remote Control Problem ğŸ“º

| **Monster Remote** ğŸ›ï¸ | **Simple Remote** ğŸ”˜ |
|:-----------------------|:--------------------|
| 100 buttons | 5 buttons |
| Confusing layout | Clear purpose |
| Many unused features | Every button useful |
| Hard to find what you need | Easy to use |

Would you rather have a simple remote with exactly what you need, or a complicated one with features you'll never use?

<InfoBox type="tip">
**The ISP Says:** Don't force users to depend on methods they don't use. Keep interfaces small and focused!
</InfoBox>

## The Worker Analogy ğŸ‘·

Imagine an interface for workers:

<SolidPrincipleDemo principle="I" mode="beginner" />

## The Problem Explained

When you create a **giant interface** with too many methods:

```
     Giant Interface
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚  interface IWorker                  â”‚
     â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
     â”‚  â€¢ Work()                           â”‚
     â”‚  â€¢ Eat()     â—€â”€â”€ Robots don't eat! â”‚
     â”‚  â€¢ Sleep()   â—€â”€â”€ Robots don't sleep!â”‚
     â”‚  â€¢ Report()                         â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼                           â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ Human   â”‚                 â”‚ Robot   â”‚
     â”‚ Worker  â”‚                 â”‚ Worker  â”‚
     â”‚ âœ… All  â”‚                 â”‚ âŒ Must â”‚
     â”‚ methods â”‚                 â”‚   fake  â”‚
     â”‚ make    â”‚                 â”‚   Eat() â”‚
     â”‚ sense   â”‚                 â”‚   and   â”‚
     â”‚         â”‚                 â”‚  Sleep()â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The robot is FORCED to implement `Eat()` and `Sleep()` even though it never uses them!

## Real-World Examples

| Too Big Interface | Better Approach |
|:------------------|:----------------|
| ğŸ“± One mega-app | Small focused apps |
| ğŸ› ï¸ Giant Swiss Army knife | Specific tools |
| ğŸ“‹ Forms asking 50 questions | Short, relevant forms |
| ğŸ½ï¸ 20-page restaurant menu | One-page menu |

## The Simple Rule

> **"Clients should not be forced to depend on interfaces they do not use."**
> â€” Robert C. Martin

Ask yourself:
- Does every class that implements this interface use ALL the methods?
- Am I forcing anyone to implement empty or fake methods?

## Good vs Bad Interfaces

| **âŒ Bad (Fat Interface)** | **âœ… Good (Segregated)** |
|:---------------------------|:------------------------|
| `IWorker { Work(), Eat(), Sleep(), Report() }` | `IWorkable { Work() }` + `IFeedable { Eat() }` |
| Forces unused implementations | Pick only what you need |
| Classes have empty methods | Every method is meaningful |
| Changes affect everyone | Changes are isolated |

## Solution: Split It Up!

```
     Segregated Interfaces
     
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ IWorkable    â”‚  â”‚ IFeedable    â”‚  â”‚ ISleepable   â”‚
     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
     â”‚ â€¢ Work()     â”‚  â”‚ â€¢ Eat()      â”‚  â”‚ â€¢ Sleep()    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                â”‚                   â”‚
            â–¼                â–¼                   â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ Human: IWorkable, IFeedable, ISleepable        â”‚
     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚
     â”‚ âœ… Implements all three - makes sense!          â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ Robot: IWorkable                                â”‚
     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                               â”‚
     â”‚ âœ… Only implements Work() - no fake methods!    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Key Takeaways

- ğŸ“º **Simple remotes** - Give users only what they need
- ğŸ§© **Small interfaces** - Many small beats one large
- ğŸš« **No empty methods** - Every method should be useful
- ğŸ¤– **Flexibility** - Classes pick only interfaces they need

<ProgressCheckpoint section="isp-introduction" xpReward={25} />
