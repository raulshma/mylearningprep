# Liskov Substitution Principle (LSP)

Barbara Liskov's principle states: **"Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program."**

## Behavioral Subtyping

LSP is about **behavioral contracts**, not just interface matching. A subclass must:

1. **Accept** at least everything the parent accepts (contravariance in input)
2. **Return** at most what the parent returns (covariance in output)
3. **Preserve** all invariants of the parent
4. **Not strengthen** preconditions
5. **Not weaken** postconditions

<InfoBox type="important">
**Key Insight:** A class can implement an interface or extend a class and still violate LSP if it doesn't honor the *behavioral* expectations.
</InfoBox>

## The Rectangle-Square Problem

The classic inheritance trap:

<DotnetCodePreview
  title="LSP Violation: Square Extends Rectangle"
  code={`public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
    
    public int CalculateArea() => Width * Height;
}

public class Square : Rectangle
{
    private int _side;
    
    public override int Width
    {
        get => _side;
        set => _side = value;  // Also changes height!
    }
    
    public override int Height
    {
        get => _side;
        set => _side = value;  // Also changes width!
    }
}

// Client code that breaks with Square
public void ResizeRectangle(Rectangle rect)
{
    rect.Width = 10;
    rect.Height = 5;
    
    // Expectation: Area = 50
    Console.WriteLine(rect.CalculateArea());
    // With Rectangle: 50 âœ…
    // With Square: 25 âŒ SURPRISE!
}`}
  steps={[
    {
      lineNumbers: [1, 2, 3, 4, 5, 6, 7],
      highlight: "Rectangle Contract",
      explanation: "Width and Height can be set independently - that's the contract"
    },
    {
      lineNumbers: [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22],
      highlight: "Square Violates Contract",
      explanation: "Setting width also sets height! This changes expected behavior."
    },
    {
      lineNumbers: [25, 26, 27, 28, 29, 30, 31, 32, 33, 34],
      highlight: "Client Breaks",
      explanation: "Code expecting Rectangle behavior gets wrong results with Square"
    }
  ]}
/>

### The Solution: Composition or Separate Hierarchy

```csharp
// Solution 1: Separate classes, shared interface
public interface IShape
{
    int CalculateArea();
}

public class Rectangle : IShape
{
    public int Width { get; set; }
    public int Height { get; set; }
    public int CalculateArea() => Width * Height;
}

public class Square : IShape
{
    public int Side { get; set; }
    public int CalculateArea() => Side * Side;
}

// No inheritance = no broken promises!
```

## Exception Handling Violations

Subclasses shouldn't throw exceptions that parents don't:

<DotnetCodePreview
  title="Exception-Based LSP Violation"
  code={`public interface IUserRepository
{
    User GetById(int id);  // Contract: Returns User or null
}

public class SqlUserRepository : IUserRepository
{
    public User GetById(int id)
    {
        var user = _db.Users.Find(id);
        return user;  // Returns null if not found âœ…
    }
}

public class CachedUserRepository : IUserRepository
{
    public User GetById(int id)
    {
        if (!_cache.Contains(id))
            throw new CacheException("Not in cache!");  // âŒ Violates LSP!
            
        return _cache.Get(id);
    }
}

// Client code
public void ProcessUser(IUserRepository repo)
{
    var user = repo.GetById(123);
    if (user == null)  // Expected behavior
        CreateNewUser();
    // But CachedUserRepository throws instead!
}`}
  steps={[
    {
      lineNumbers: [1, 2, 3, 4],
      highlight: "Interface Contract",
      explanation: "Implicit contract: returns User or null, no exceptions expected"
    },
    {
      lineNumbers: [15, 16, 17, 18, 19, 20, 21, 22, 23],
      highlight: "Violation",
      explanation: "Throws an exception instead of returning null - breaks substitutability"
    }
  ]}
/>

## Precondition and Postcondition Rules

| Rule | Meaning | Example |
|:-----|:--------|:--------|
| **Don't strengthen preconditions** | Subclass can't require MORE | Parent: accepts any int. Child: can't require int > 0 |
| **Don't weaken postconditions** | Subclass can't promise LESS | Parent: always returns non-null. Child: can't return null |

<SolidPrincipleDemo principle="L" mode="intermediate" />

## Common LSP Violations

### 1. Empty Method Implementations

```csharp
public class Bird
{
    public virtual void Fly() => /* flying logic */;
}

public class Penguin : Bird
{
    public override void Fly() 
    { 
        // Do nothing âŒ - Violates expected behavior
    }
}
```

### 2. Type Checking in Client Code

When clients need to check types, you've violated LSP:

```csharp
public void MakeBirdFly(Bird bird)
{
    if (bird is Penguin)  // âŒ LSP smell!
        bird.Swim();
    else
        bird.Fly();
}
```

### 3. NotImplementedException

```csharp
public class FileLogger : ILogger
{
    public void Log(string message) => File.AppendAllText(logPath, message);
    
    public void LogError(Exception ex)
    {
        throw new NotImplementedException();  // âŒ Breaks contract!
    }
}
```

## Design Patterns That Enforce LSP

### Template Method Pattern

Ensures subclasses follow parent's algorithm:

```csharp
public abstract class DocumentProcessor
{
    // Template method - defines the algorithm
    public void Process(Document doc)
    {
        Validate(doc);      // Step 1: All subclasses validate
        Transform(doc);     // Step 2: Subclass-specific logic
        Save(doc);          // Step 3: All subclasses save
    }
    
    protected abstract void Validate(Document doc);
    protected abstract void Transform(Document doc);
    
    protected virtual void Save(Document doc) 
        => _repository.Save(doc);
}

// Subclasses MUST follow parent's algorithm structure
public class PdfProcessor : DocumentProcessor
{
    protected override void Validate(Document doc) => /* PDF validation */;
    protected override void Transform(Document doc) => /* PDF transform */;
}
```

## Testing for LSP Compliance

Write tests that use the base type and run against all subtypes:

```csharp
[Theory]
[MemberData(nameof(GetAllShapes))]
public void Area_AlwaysPositive(IShape shape)
{
    // This test should pass for ALL shape implementations
    Assert.True(shape.CalculateArea() >= 0);
}

public static IEnumerable<object[]> GetAllShapes()
{
    yield return new object[] { new Rectangle { Width = 5, Height = 3 } };
    yield return new object[] { new Square { Side = 4 } };
    yield return new object[] { new Circle { Radius = 2 } };
}
```

## Key Takeaways

- ğŸ“ **Contracts matter** - Behavior, not just interface signatures
- ğŸš« **No surprises** - Subclass shouldn't throw unexpected exceptions
- ğŸ”’ **Preconditions** - Can weaken (accept more), never strengthen
- ğŸ”“ **Postconditions** - Can strengthen (promise more), never weaken
- ğŸ§ª **Test polymorphically** - All subtypes should pass parent's tests

<ProgressCheckpoint section="lsp-understanding" xpReward={40} />
