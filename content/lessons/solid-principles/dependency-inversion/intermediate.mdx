# Dependency Inversion Principle (DIP)

The Dependency Inversion Principle has two parts:

1. **High-level modules should not depend on low-level modules.** Both should depend on abstractions.
2. **Abstractions should not depend on details.** Details should depend on abstractions.

## Understanding High-Level vs Low-Level

| Level | Description | Examples |
|:------|:------------|:---------|
| **High-Level** | Business logic, orchestration | `OrderService`, `InvoiceProcessor` |
| **Low-Level** | Technical details, infrastructure | `SqlDatabase`, `SmtpEmailSender` |

<InfoBox type="important">
**Key Insight:** "High-level" doesn't mean more important. It means closer to the business domain. "Low-level" means closer to implementation details.
</InfoBox>

## The Problem: Inverted Dependencies

Traditional layered architecture creates **fragile dependencies**:

<DotnetCodePreview
  title="Violating DIP: Direct Dependencies"
  code={`// Low-level module (infrastructure)
public class SqlServerDatabase
{
    private readonly string _connectionString;
    
    public SqlServerDatabase(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public void SaveOrder(Order order)
    {
        using var connection = new SqlConnection(_connectionString);
        // SQL-specific implementation
    }
}

// High-level module (business logic)
public class OrderService
{
    // ‚ùå DIRECT dependency on concrete implementation
    private readonly SqlServerDatabase _database;
    
    public OrderService()
    {
        // ‚ùå Creates its own dependency - tightly coupled!
        _database = new SqlServerDatabase("Server=...");
    }
    
    public void PlaceOrder(OrderRequest request)
    {
        var order = new Order(request);
        _database.SaveOrder(order);  // Bound to SQL Server forever!
    }
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
      highlight: "Low-Level Module",
      explanation: "Infrastructure detail - SQL Server specific code"
    },
    {
      lineNumbers: [20, 21, 22],
      highlight: "Direct Dependency",
      explanation: "High-level module depends on concrete low-level class"
    },
    {
      lineNumbers: [24, 25, 26, 27],
      highlight: "Self-Created Dependency",
      explanation: "OrderService creates its own database - cannot be swapped!"
    }
  ]}
/>

**Problems:**

- ‚ùå Can't test `OrderService` without SQL Server
- ‚ùå Can't switch to PostgreSQL without modifying `OrderService`
- ‚ùå Business logic polluted with infrastructure decisions

## The Solution: Invert the Dependency

<DotnetCodePreview
  title="Applying DIP: Abstraction Layer"
  code={`// Abstraction: The "contract" owned by the high-level module
public interface IOrderRepository
{
    void Save(Order order);
    Order GetById(int id);
}

// High-level module depends on abstraction
public class OrderService
{
    private readonly IOrderRepository _repository;
    
    // ‚úÖ Dependency INJECTED through constructor
    public OrderService(IOrderRepository repository)
    {
        _repository = repository;
    }
    
    public void PlaceOrder(OrderRequest request)
    {
        var order = new Order(request);
        _repository.Save(order);  // Doesn't know or care about SQL!
    }
}

// Low-level module implements the abstraction
public class SqlServerOrderRepository : IOrderRepository
{
    private readonly string _connectionString;
    
    public SqlServerOrderRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public void Save(Order order)
    {
        using var connection = new SqlConnection(_connectionString);
        // SQL-specific implementation
    }
    
    public Order GetById(int id) { /* ... */ }
}

// Alternative implementation - same interface!
public class MongoOrderRepository : IOrderRepository
{
    private readonly IMongoDatabase _db;
    
    public void Save(Order order)
    {
        _db.GetCollection<Order>("orders").InsertOne(order);
    }
    
    public Order GetById(int id) { /* ... */ }
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6],
      highlight: "Abstraction",
      explanation: "Interface defines what's needed, not how it's done"
    },
    {
      lineNumbers: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22],
      highlight: "High-Level Module",
      explanation: "Depends on abstraction, receives implementation via constructor"
    },
    {
      lineNumbers: [42, 43, 44, 45, 46, 47, 48, 49, 50, 51],
      highlight: "Alternative Implementation",
      explanation: "Same interface, different database - OrderService unchanged!"
    }
  ]}
/>

<SolidPrincipleDemo principle="D" mode="intermediate" />

## Dependency Injection in ASP.NET Core

ASP.NET Core has built-in dependency injection that makes DIP easy:

```csharp
// Program.cs / Startup.cs - Configuration
var builder = WebApplication.CreateBuilder(args);

// Register abstraction with implementation
builder.Services.AddScoped<IOrderRepository, SqlServerOrderRepository>();

// Or based on configuration
if (builder.Configuration["Database"] == "Mongo")
    builder.Services.AddScoped<IOrderRepository, MongoOrderRepository>();
else
    builder.Services.AddScoped<IOrderRepository, SqlServerOrderRepository>();

// Controller receives dependency automatically
public class OrdersController : ControllerBase
{
    private readonly IOrderRepository _repository;
    
    // ASP.NET Core injects the configured implementation
    public OrdersController(IOrderRepository repository)
    {
        _repository = repository;
    }
}
```

## Service Lifetimes

| Lifetime | Description | Use Case |
|:---------|:------------|:---------|
| **Transient** | New instance every time | Lightweight, stateless services |
| **Scoped** | One instance per request | Database contexts, unit of work |
| **Singleton** | One instance for application | Caches, configuration |

```csharp
services.AddTransient<IEmailSender, SmtpEmailSender>();  // New each time
services.AddScoped<IOrderRepository, SqlOrderRepository>(); // Per request
services.AddSingleton<ICacheService, RedisCacheService>();  // App lifetime
```

## Testing Benefits

DIP enables easy unit testing:

```csharp
// Without DIP: Need real database
[Test]
public void PlaceOrder_Tests()
{
    var service = new OrderService();  // Creates real SqlServerDatabase!
    // Need SQL Server running... üò±
}

// With DIP: Use test doubles
[Test]
public void PlaceOrder_SavesOrder_ToRepository()
{
    // Arrange
    var mockRepository = new Mock<IOrderRepository>();
    var service = new OrderService(mockRepository.Object);
    
    // Act
    service.PlaceOrder(new OrderRequest { /* ... */ });
    
    // Assert
    mockRepository.Verify(r => r.Save(It.IsAny<Order>()), Times.Once);
}

// Or use a simple fake
public class FakeOrderRepository : IOrderRepository
{
    public List<Order> SavedOrders { get; } = new();
    
    public void Save(Order order) => SavedOrders.Add(order);
    public Order GetById(int id) => SavedOrders.FirstOrDefault(o => o.Id == id);
}
```

## Common Mistakes

### ‚ùå Service Locator Anti-Pattern

```csharp
public class OrderService
{
    public void PlaceOrder()
    {
        // ‚ùå Hides dependencies, hard to test
        var repo = ServiceLocator.Resolve<IOrderRepository>();
        repo.Save(new Order());
    }
}
```

### ‚úÖ Constructor Injection

```csharp
public class OrderService
{
    private readonly IOrderRepository _repo;
    
    // ‚úÖ Explicit dependencies, easy to test
    public OrderService(IOrderRepository repo)
    {
        _repo = repo;
    }
}
```

## Key Takeaways

- üîå **Depend on interfaces** not concrete classes
- üíâ **Inject dependencies** through constructors
- üèÅ **Configure at startup** not in business logic
- üß™ **Testing is easy** with mock implementations
- üîÑ **Swapping is easy** change config, not code

<ProgressCheckpoint section="dip-understanding" xpReward={40} />
