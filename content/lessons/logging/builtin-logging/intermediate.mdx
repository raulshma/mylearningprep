# Built-in Logging: Deep Dive into ILogger

ASP.NET Core's logging abstraction provides a flexible, provider-based system that separates logging logic from log output destinations. Understanding this architecture enables effective application monitoring and troubleshooting.

## The ILogger Interface

The `ILogger<T>` interface is the core abstraction for logging in .NET:

```csharp
public interface ILogger<out TCategoryName> : ILogger
{
}

public interface ILogger
{
    void Log<TState>(LogLevel logLevel, EventId eventId, TState state, 
                     Exception? exception, Func<TState, Exception?, string> formatter);
    bool IsEnabled(LogLevel logLevel);
    IDisposable BeginScope<TState>(TState state);
}
```

The generic `ILogger<T>` uses the type parameter as the **category name**, which helps identify where logs originated.

<ProgressCheckpoint section="logging-fundamentals" xpReward={15} />

## Log Levels in Detail

Each log level has specific semantics and use cases:

```csharp
public class PaymentService
{
    private readonly ILogger<PaymentService> _logger;

    public async Task<PaymentResult> ProcessPayment(PaymentRequest request)
    {
        // Trace: Very detailed information for diagnosing specific issues
        _logger.LogTrace("ProcessPayment called with RequestId: {RequestId}", request.Id);

        // Debug: Information useful during development
        _logger.LogDebug("Validating payment amount: {Amount} {Currency}", 
            request.Amount, request.Currency);

        if (!ValidateAmount(request.Amount))
        {
            // Warning: Unexpected but not critical situation
            _logger.LogWarning("Invalid payment amount {Amount} for request {RequestId}", 
                request.Amount, request.Id);
            return PaymentResult.Invalid;
        }

        // Information: General flow of the application
        _logger.LogInformation("Processing payment {RequestId} for amount {Amount}", 
            request.Id, request.Amount);

        try
        {
            var result = await _paymentGateway.ChargeAsync(request);
            
            _logger.LogInformation("Payment {RequestId} processed successfully. TransactionId: {TransactionId}",
                request.Id, result.TransactionId);
                
            return result;
        }
        catch (PaymentDeclinedException ex)
        {
            // Error: Recoverable error that doesn't break the application
            _logger.LogError(ex, "Payment declined for request {RequestId}. Reason: {Reason}",
                request.Id, ex.Reason);
            throw;
        }
        catch (OutOfMemoryException ex)
        {
            // Critical: System failure requiring immediate attention
            _logger.LogCritical(ex, "Critical memory failure during payment processing");
            throw;
        }
    }
}
```

### Message Templates

ASP.NET Core logging uses **structured message templates** (similar to Serilog):

```csharp
// ❌ Bad: String interpolation loses structured data
_logger.LogInformation($"User {userId} logged in from {ipAddress}");

// ✅ Good: Message template preserves structure
_logger.LogInformation("User {UserId} logged in from {IpAddress}", userId, ipAddress);
```

The second approach creates structured log entries where `UserId` and `IpAddress` are separate properties, not just text.

<ProgressCheckpoint section="log-levels" xpReward={15} />

## Logging Providers

Providers determine where logs are written. ASP.NET Core includes several built-in providers:

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

builder.Logging
    .ClearProviders()           // Remove all defaults
    .AddConsole()              // Console output
    .AddDebug()                // Debug output (Visual Studio)
    .AddEventSourceLogger()    // EventSource for diagnostics
    .AddEventLog();            // Windows Event Log

var app = builder.Build();
```

### Provider-Specific Configuration

Each provider can have its own configuration:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    },
    "Console": {
      "LogLevel": {
        "Default": "Debug"
      },
      "FormatterName": "json",
      "FormatterOptions": {
        "SingleLine": true,
        "IncludeScopes": true,
        "TimestampFormat": "yyyy-MM-dd HH:mm:ss ",
        "UseUtcTimestamp": true
      }
    },
    "EventLog": {
      "LogLevel": {
        "Default": "Warning"
      }
    }
  }
}
```

## Filtering Logs

Filtering controls which logs are written based on category and level:

### Configuration-Based Filtering

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "MyApp": "Debug",
      "MyApp.Services.PaymentService": "Trace",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning"
    }
  }
}
```

This configuration:
- Sets default to Information
- MyApp namespace logs at Debug level
- PaymentService logs everything (Trace)
- EF Core SQL commands only show warnings

### Code-Based Filtering

```csharp
builder.Logging.AddFilter("System", LogLevel.Warning)
               .AddFilter("Microsoft", LogLevel.Warning)
               .AddFilter<ConsoleLoggerProvider>("MyApp.Controllers", LogLevel.Debug);
```

## Log Scopes

Scopes add contextual information to all logs within a using block:

```csharp
public class OrdersController : ControllerBase
{
    private readonly ILogger<OrdersController> _logger;

    [HttpGet("{id}")]
    public async Task<IActionResult> GetOrder(int id)
    {
        using (_logger.BeginScope("Processing order {OrderId}", id))
        {
            _logger.LogInformation("Fetching order from database");
            var order = await _db.Orders.FindAsync(id);
            
            _logger.LogInformation("Validating order status");
            if (order.Status == OrderStatus.Cancelled)
            {
                _logger.LogWarning("Attempted to access cancelled order");
                return NotFound();
            }
            
            return Ok(order);
        }
    }
}
```

All logs within the scope automatically include `OrderId`, creating context for troubleshooting.

<ProgressCheckpoint section="providers-filtering" xpReward={10} />

## Performance Considerations

### Log Level Guards

Check if logging is enabled before expensive operations:

```csharp
if (_logger.IsEnabled(LogLevel.Debug))
{
    var diagnosticData = await CollectExpensiveDiagnosticsAsync();
    _logger.LogDebug("Diagnostic data: {Data}", diagnosticData);
}
```

### Message Delegates

For expensive string formatting:

```csharp
// Only formats if Debug logging is enabled
_logger.LogDebug(() => $"Complex computation result: {ExpensiveCalculation()}");
```

## Best Practices

| Do | Don't |
|:---|:------|
| Use message templates | Use string interpolation |
| Log exceptions with `LogError(ex, ...)` | Just log `ex.Message` |
| Use appropriate log levels | Log everything as Information |
| Include contextual data | Log generic messages |
| Use scopes for request correlation | Manually add request IDs everywhere |

<InfoBox type="tip">
**Performance Tip**: In production, set `Microsoft.AspNetCore` to Warning or Error level to reduce noise from framework internals.
</InfoBox>

<InfoBox type="success">
You now understand the architecture and best practices of ASP.NET Core's logging system. You can configure providers, filter logs effectively, and use structured logging for better observability.
</InfoBox>
