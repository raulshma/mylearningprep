# Distributed Caching with Redis: Sharing is Caring!

Imagine you and your friends are working on a group project at different coffee shops around the city. You need to share notes, but keeping them on your laptop only works when you're connected. What if you stored them in a **shared Google Doc** that everyone can access?

That's exactly what **Redis** does for your servers!

## What is Distributed Caching?

When you have multiple servers running your application (like Netflix or Amazon), each server needs access to the **same cached data**. 

**In-memory cache** = Each server has its own notepad (not shared)  
**Distributed cache (Redis)** = All servers share one big whiteboard!

<InfoBox type="info">
**Redis** stands for **RE**mote **DI**ctionary **S**erver. It's a super-fast database that lives in memory and can be accessed by all your application servers.
</InfoBox>

## Why Use Redis?

| In-Memory Cache | Redis (Distributed) |
|:----------------|:-------------------|
| ğŸ  Lives on each server | â˜ï¸ Shared across all servers |
| âŒ Data not shared | âœ… Everyone sees the same data |
| ğŸ˜° Inconsistent after updates | ğŸ˜ Always consistent |
| ğŸ’” Lost after server restart | ğŸ’š Persists (can save to disk) |

## Real-World Analogy

Think of a **shopping cart** on Amazon:

**Without Redis:**
- You add items on Server 1
- Next request goes to Server 2
- Your cart is empty! ğŸ˜±

**With Redis:**
- You add items â†’ stored in Redis
- Next request goes to any server
- Your cart is there! ğŸ‰

<DotnetCodePreview 
  language="csharp"
  code={`// Setup in Program.cs
builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = "localhost:6379"; // Redis server
    options.InstanceName = "MyApp:";
});

// Use in your service
public class ShoppingCartService
{
    private readonly IDistributedCache _cache;
    
    public ShoppingCartService(IDistributedCache cache)
    {
        _cache = cache;
    }
    
    public async Task AddToCartAsync(string userId, Product product)
    {
        var cartKey = $"cart:{userId}";
        var cartJson = await _cache.GetStringAsync(cartKey);
        
        // Get existing cart or create new one
        var cart = string.IsNullOrEmpty(cartJson) 
            ? new List<Product>() 
            : JsonSerializer.Deserialize<List<Product>>(cartJson);
        
        cart.Add(product);
        
        // Save back to Redis
        await _cache.SetStringAsync(
            cartKey, 
            JsonSerializer.Serialize(cart),
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(7)
            }
        );
    }
}`}
/>

## How Does It Work?

1. ğŸŒ **Multiple Servers** all connect to Redis
2. ğŸ“¦ **Server A** saves data to Redis
3. âš¡ **Server B** can instantly read that data
4. ğŸ”„ Everyone stays synchronized!

<InfoBox type="tip">
**Redis is FAST!** It can handle 100,000+ operations per second because everything is stored in RAM.
</InfoBox>

## Common Use Cases

âœ… **Perfect for Redis:**
- ğŸ›’ Shopping carts
- ğŸ‘¤ User sessions
- ğŸ« Authentication tokens
- ğŸ“Š Real-time analytics
- ğŸ”” Notification queues

âŒ **Don't Use Redis For:**
- ğŸ“ Large files (over 512MB)
- ğŸ¦ Primary data storage (use a database)
- ğŸ” Unencrypted sensitive data

## Basic Redis Operations

### Storing Simple Values

```csharp
// Store a string
await _cache.SetStringAsync("username:123", "JohnDoe");

// Retrieve a string
var username = await _cache.GetStringAsync("username:123");
```

### Storing Complex Objects

```csharp
// Store an object as JSON
var user = new User { Id = 123, Name = "John" };
await _cache.SetStringAsync(
    "user:123", 
    JsonSerializer.Serialize(user)
);

// Retrieve and deserialize
var userJson = await _cache.GetStringAsync("user:123");
var retrievedUser = JsonSerializer.Deserialize<User>(userJson);
```

### Setting Expiration

```csharp
var options = new DistributedCacheEntryOptions
{
    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30),
    SlidingExpiration = TimeSpan.FromMinutes(5)
};

await _cache.SetStringAsync("session:abc", sessionData, options);
```

## Key Differences from In-Memory Cache

| Feature | In-Memory | Redis |
|:--------|:----------|:------|
| Speed | âš¡âš¡âš¡ Super fast | âš¡âš¡ Very fast |
| Shared? | âŒ No | âœ… Yes |
| Persistence | âŒ Lost on restart | âœ… Can persist |
| Cost | ğŸ’° Free (uses RAM) | ğŸ’°ğŸ’° Requires Redis server |
| Setup | Easy | Moderate |

<InfoBox type="warning">
**Remember**: With Redis, you're making a network call. It's still fast, but slightly slower than in-memory cache on the same server.
</InfoBox>

## When to Choose Redis?

âœ… **Use Redis when:**
- Multiple servers need shared cache
- Cache must survive server restarts
- You need pub/sub messaging
- Session data for logged-in users

âŒ **Stick with in-memory when:**
- Single server application
- Data is specific to each server
- Ultra-low latency required
- Small development projects

<ProgressCheckpoint section="redis-caching-basics" xpReward={20} />
