# gRPC Fundamentals - Advanced Architecture

gRPC represents a paradigm shift in distributed systems communication, leveraging modern protocols and serialization techniques to achieve unprecedented performance and efficiency. Let's explore the internals.

## Protocol Stack Deep Dive

<GrpcArchitectureVisualizer />

### HTTP/2 Framing Layer

gRPC operates on top of HTTP/2, which provides several critical features:

#### Binary Framing Protocol
```
HTTP/2 Frame Structure:
+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+-------------------------------+
|R|                 Stream Identifier (31)      |
+=+==============================================+
|                   Frame Payload (0...)        |
+-----------------------------------------------+
```

**Frame Types Used by gRPC:**
- `HEADERS`: RPC metadata and headers
- `DATA`: Protobuf-encoded message payload
- `RST_STREAM`: Early termination signal
- `GOAWAY`: Graceful connection shutdown

#### Multiplexing & Concurrency

HTTP/2 multiplexing enables:
- **Stream Concurrency**: 100+ concurrent RPCs on single TCP connection
- **Stream Prioritization**: Critical requests get precedence
- **Flow Control**: Per-stream and connection-level backpressure

```csharp
// Multiple concurrent calls on same channel
var channel = GrpcChannel.ForAddress("https://api.example.com");
var client = new UserService.UserServiceClient(channel);

// All three calls multiplex over same TCP connection
var task1 = client.GetUserAsync(new GetUserRequest { Id = 1 });
var task2 = client.GetUserAsync(new GetUserRequest { Id = 2 });
var task3 = client.GetUserAsync(new GetUserRequest { Id = 3 });

await Task.WhenAll(task1, task2, task3);
```

<ProgressCheckpoint section="what-is-grpc" xpReward={60} />

## Protocol Buffers Encoding

### Wire Format Efficiency

Protobuf uses **variable-length encoding** and **field numbering** for extreme compactness:

```protobuf
message User {
  int32 id = 1;      // Field number 1
  string name = 2;   // Field number 2
  string email = 3;  // Field number 3
}
```

**Binary Encoding:**
```
Field 1 (id = 42):     0x08 0x2A        (2 bytes)
Field 2 (name = "Bob"): 0x12 0x03 0x42 0x6F 0x62 (5 bytes)
```

**Compare to JSON:**
```json
{"id":42,"name":"Bob"}  // 22 bytes
```

### Backward/Forward Compatibility

Protobuf's **field numbering** enables schema evolution:

```protobuf
// Version 1
message User {
  int32 id = 1;
  string name = 2;
}

// Version 2 (backward compatible)
message User {
  int32 id = 1;
  string name = 2;
  string email = 3;      // New field
  repeated string tags = 4;  // New repeated field
}
```

**Rules for Compatibility:**
- Never change field numbers
- Add new fields with new numbers
- Use `reserved` for deleted fields
- Optional fields default to zero values

<ProgressCheckpoint section="grpc-vs-rest" xpReward={60} />

## Streaming Patterns & Flow Control

<StreamingPatternVisualizer />

### Bidirectional Streaming with Flow Control

gRPC implements **application-level flow control** on top of HTTP/2:

```csharp
public override async Task Chat(
    IAsyncStreamReader<ChatMessage> requestStream,
    IServerStreamWriter<ChatMessage> responseStream,
    ServerCallContext context)
{
    // Buffer for flow control
    var buffer = Channel.CreateBounded<ChatMessage>(
        new BoundedChannelOptions(32) {
            FullMode = BoundedChannelFullMode.Wait
        }
    );
    
    // Consumer task
    var consumer = Task.Run(async () =>
    {
        await foreach (var msg in requestStream.ReadAllAsync())
        {
            // Backpressure: Wait if buffer full
            await buffer.Writer.WriteAsync(msg, context.CancellationToken);
        }
        buffer.Writer.Complete();
    });
    
    // Producer task
    await foreach (var msg in buffer.Reader.ReadAllAsync())
    {
        // HTTP/2 flow control handles downstream backpressure
        await responseStream.WriteAsync(msg);
    }
    
    await consumer;
}
```

### Deadline Propagation

gRPC **propagates deadlines** across service boundaries:

```csharp
// Client sets 5-second deadline
var call = client.GetUserAsync(
    new GetUserRequest { Id = 1 },
    deadline: DateTime.UtcNow.AddSeconds(5)
);

// Server checks remaining time
public override async Task<UserResponse> GetUser(
    GetUserRequest request, 
    ServerCallContext context)
{
    // Deadline is automatically propagated
    var remaining = context.Deadline - DateTime.UtcNow;
    
    if (remaining < TimeSpan.FromMilliseconds(500))
    {
        throw new RpcException(new Status(
            StatusCode.DeadlineExceeded, 
            "Insufficient time to complete request"
        ));
    }
    
    // Use remaining time for downstream calls
    var user = await _repository.GetUserAsync(
        request.Id, 
        context.CancellationToken
    );
    
    return user;
}
```

<ProgressCheckpoint section="grpc-architecture" xpReward={60} />

## Performance Optimization Techniques

### 1. Connection Pooling & Reuse

```csharp
// WRONG: Creates new connection per request
public async Task<User> GetUserAsync(int id)
{
    using var channel = GrpcChannel.ForAddress("https://api.example.com");
    var client = new UserService.UserServiceClient(channel);
    return await client.GetUserAsync(new GetUserRequest { Id = id });
}

// CORRECT: Reuse channel (connection pool)
private static readonly GrpcChannel _channel = 
    GrpcChannel.ForAddress("https://api.example.com", new GrpcChannelOptions {
        HttpHandler = new SocketsHttpHandler {
            PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan,
            KeepAlivePingDelay = TimeSpan.FromSeconds(60),
            KeepAlivePingTimeout = TimeSpan.FromSeconds(30),
            EnableMultipleHttp2Connections = true
        }
    });

public async Task<User> GetUserAsync(int id)
{
    var client = new UserService.UserServiceClient(_channel);
    return await client.GetUserAsync(new GetUserRequest { Id = id });
}
```

### 2. Compression

```csharp
// Enable gzip compression for large messages
var call = client.CreateUserAsync(
    new CreateUserRequest { /* large payload */ },
    new CallOptions(
        compression: "gzip",
        writeOptions: new WriteOptions(WriteFlags.NoCompress) // Per-message control
    )
);
```

### 3. Message Batching

```csharp
// Instead of 1000 unary calls, use client streaming
using var call = client.BatchCreateUsers();

foreach (var user in users)
{
    await call.RequestStream.WriteAsync(new CreateUserRequest { 
        User = user 
    });
}

await call.RequestStream.CompleteAsync();
var response = await call.ResponseAsync;
```

## Security Considerations

### TLS/SSL Configuration

```csharp
// Production: Enforce TLS 1.3 with certificate validation
var httpHandler = new SocketsHttpHandler {
    SslOptions = new SslClientAuthenticationOptions {
        EnabledSslProtocols = SslProtocols.Tls13,
        CertificateRevocationCheckMode = X509RevocationMode.Online,
        RemoteCertificateValidationCallback = (sender, cert, chain, errors) => {
            // Custom certificate validation
            return errors == SslPolicyErrors.None;
        }
    }
};

var channel = GrpcChannel.ForAddress("https://api.example.com", new GrpcChannelOptions {
    HttpHandler = httpHandler
});
```

### Interceptors for Authentication

```csharp
public class AuthInterceptor : Interceptor
{
    private readonly ITokenProvider _tokenProvider;
    
    public override AsyncUnaryCall<TResponse> AsyncUnaryCall<TRequest, TResponse>(
        TRequest request,
        ClientInterceptorContext<TRequest, TResponse> context,
        AsyncUnaryCallContinuation<TRequest, TResponse> continuation)
    {
        var token = await _tokenProvider.GetTokenAsync();
        
        var headers = new Metadata {
            { "Authorization", $"Bearer {token}" }
        };
        
        var options = context.Options.WithHeaders(headers);
        var newContext = new ClientInterceptorContext<TRequest, TResponse>(
            context.Method, context.Host, options
        );
        
        return continuation(request, newContext);
    }
}

// Register interceptor
var channel = GrpcChannel.ForAddress("https://api.example.com");
var invoker = channel.Intercept(new AuthInterceptor(tokenProvider));
var client = new UserService.UserServiceClient(invoker);
```

## Observability & Monitoring

### Distributed Tracing

gRPC integrates with OpenTelemetry for distributed tracing:

```csharp
// Configure tracing
services.AddGrpc(options => {
    options.EnableDetailedErrors = true;
    options.Interceptors.Add<TracingInterceptor>();
});

public class TracingInterceptor : Interceptor
{
    public override async Task<TResponse> UnaryServerHandler<TRequest, TResponse>(
        TRequest request,
        ServerCallContext context,
        UnaryServerMethod<TRequest, TResponse> continuation)
    {
        using var activity = Activity.StartActivity($"gRPC {context.Method}");
        activity?.SetTag("rpc.service", context.Method);
        activity?.SetTag("rpc.grpc.status_code", StatusCode.OK);
        
        try
        {
            return await continuation(request, context);
        }
        catch (RpcException ex)
        {
            activity?.SetTag("rpc.grpc.status_code", ex.StatusCode);
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            throw;
        }
    }
}
```

## Advanced Topics

- **Load Balancing**: Client-side LB with `grpc-lb` protocol
- **Service Mesh**: Istio, Linkerd for sidecar proxies
- **Health Checking**: `grpc.health.v1.Health` service
- **Reflection**: `grpc.reflection.v1alpha.ServerReflection`
- **gRPC-Web**: Browser support via Envoy proxy
- **xDS Protocol**: Dynamic configuration (Envoy, Traffic Director)

<InfoBox type="warning">
**Production Consideration:** Always implement proper **circuit breakers**, **retry policies**, and **timeout strategies** when using gRPC in microservices architectures.
</InfoBox>
