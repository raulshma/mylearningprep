# Advanced Multi-Mapping with Dapper

You've mastered the basics of multi-mapping. Now let's tackle complex scenarios: one-to-many relationships, handling duplicates, custom split logic, and performance optimization for large-scale applications.

<InfoBox type="tip" title="Advanced Techniques Ahead">
This lesson covers aggregated collections, dictionary-based lookups for deduplication, and architectural patterns for maintainable data access layers.
</InfoBox>

<ProgressCheckpoint section="introduction-multi-mapping" xpReward={12} />

## One-to-Many Relationships: The Grouping Challenge

The most common advanced scenario is mapping one-to-many relationships. For example, one customer has many orders. The challenge? SQL JOINs create duplicate parent records.

### The Problem

```sql
SELECT c.*, o.*
FROM Customers c
LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
WHERE c.CustomerId = 1
```

**Result:**
| CustomerId | Name  | Email       | OrderId | Total |
|------------|-------|-------------|---------|-------|
| 1          | Alice | alice@...   | 101     | 50.00 |
| 1          | Alice | alice@...   | 102     | 75.00 |
| 1          | Alice | alice@...   | 103     | 30.00 |

Notice Alice appears three times! We need to **deduplicate** and build a collection.

### Solution: Dictionary-Based Deduplication

```csharp
public class Customer
{
    public int CustomerId { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public List<Order> Orders { get; set; } = new List<Order>();
}

public class Order
{
    public int OrderId { get; set; }
    public int CustomerId { get; set; }
    public decimal Total { get; set; }
    public DateTime OrderDate { get; set; }
}

var sql = @"
    SELECT c.*, o.*
    FROM Customers c
    LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
    WHERE c.CustomerId = @customerId";

var customerDictionary = new Dictionary<int, Customer>();

var result = connection.Query<Customer, Order, Customer>(
    sql,
    (customer, order) =>
    {
        // Check if we've seen this customer before
        if (!customerDictionary.TryGetValue(customer.CustomerId, out var existingCustomer))
        {
            // First time seeing this customer
            existingCustomer = customer;
            customerDictionary.Add(customer.CustomerId, existingCustomer);
        }

        // Add the order to the customer's collection
        if (order != null) // Handle LEFT JOIN nulls
        {
            existingCustomer.Orders.Add(order);
        }

        return existingCustomer;
    },
    new { customerId = 1 },
    splitOn: "OrderId"
);

// Get the unique customer with all orders
var customer = customerDictionary.Values.FirstOrDefault();

Console.WriteLine($"Customer: {customer.Name}");
foreach (var order in customer.Orders)
{
    Console.WriteLine($"  Order #{order.OrderId}: ${order.Total}");
}
```

<KeyConcept title="Why Use a Dictionary?">
Without the dictionary, Dapper would create a new Customer object for each row, giving you three separate Alice objects. The dictionary acts as a **lookup cache** to ensure we only have one Customer instance, with all orders added to its collection.
</KeyConcept>

<ProgressCheckpoint section="two-type-mapping" xpReward={12} />

## Generic Helper Method for One-to-Many

Create a reusable extension method:

```csharp
public static class DapperExtensions
{
    public static IEnumerable<TParent> QueryOneToMany<TParent, TChild, TKey>(
        this IDbConnection connection,
        string sql,
        Func<TParent, TKey> parentKeySelector,
        Func<TParent, IList<TChild>> childListSelector,
        object param = null,
        string splitOn = "Id")
    {
        var lookup = new Dictionary<TKey, TParent>();

        connection.Query<TParent, TChild, TParent>(
            sql,
            (parent, child) =>
            {
                var key = parentKeySelector(parent);
                
                if (!lookup.TryGetValue(key, out var existingParent))
                {
                    existingParent = parent;
                    lookup.Add(key, existingParent);
                }

                if (child != null)
                {
                    var childList = childListSelector(existingParent);
                    childList.Add(child);
                }

                return existingParent;
            },
            param,
            splitOn: splitOn
        );

        return lookup.Values;
    }
}

// Usage - much cleaner!
var customers = connection.QueryOneToMany<Customer, Order, int>(
    sql,
    parent => parent.CustomerId,           // Key selector
    parent => parent.Orders,                // Child collection selector
    new { customerId = 1 },
    splitOn: "OrderId"
);
```

<ProgressCheckpoint section="spliton-parameter" xpReward={12} />

## Multi-Level Relationships

What if an Order has OrderItems, creating a three-level hierarchy?

```csharp
public class Customer
{
    public int CustomerId { get; set; }
    public string Name { get; set; }
    public List<Order> Orders { get; set; } = new List<Order>();
}

public class Order
{
    public int OrderId { get; set; }
    public DateTime OrderDate { get; set; }
    public decimal Total { get; set; }
    public List<OrderItem> Items { get; set; } = new List<OrderItem>();
}

public class OrderItem
{
    public int OrderItemId { get; set; }
    public int OrderId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}

var sql = @"
    SELECT c.*, o.*, oi.*
    FROM Customers c
    LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
    LEFT JOIN OrderItems oi ON oi.OrderId = o.OrderId
    WHERE c.CustomerId = @customerId";

var customerLookup = new Dictionary<int, Customer>();
var orderLookup = new Dictionary<int, Order>();

var result = connection.Query<Customer, Order, OrderItem, Customer>(
    sql,
    (customer, order, orderItem) =>
    {
        // Deduplicate customer
        if (!customerLookup.TryGetValue(customer.CustomerId, out var existingCustomer))
        {
            existingCustomer = customer;
            customerLookup.Add(customer.CustomerId, existingCustomer);
        }

        // Deduplicate order
        if (order != null)
        {
            if (!orderLookup.TryGetValue(order.OrderId, out var existingOrder))
            {
                existingOrder = order;
                orderLookup.Add(order.OrderId, existingOrder);
                existingCustomer.Orders.Add(existingOrder);
            }

            // Add item to order
            if (orderItem != null)
            {
                existingOrder.Items.Add(orderItem);
            }
        }

        return existingCustomer;
    },
    new { customerId = 1 },
    splitOn: "OrderId,OrderItemId"
);

var customer = customerLookup.Values.First();
```

<DapperMultiMappingVisualizer />

<ProgressCheckpoint section="three-plus-types" xpReward={12} />

## QueryMultiple: Avoiding JOIN Complexity

Sometimes it's more efficient to execute multiple queries instead of complex JOINs:

```csharp
var sql = @"
    SELECT * FROM Customers WHERE CustomerId = @customerId;
    SELECT * FROM Orders WHERE CustomerId = @customerId;
    SELECT oi.* 
    FROM OrderItems oi
    INNER JOIN Orders o ON o.OrderId = oi.OrderId
    WHERE o.CustomerId = @customerId;";

using (var multi = connection.QueryMultiple(sql, new { customerId = 1 }))
{
    var customer = multi.ReadSingle<Customer>();
    customer.Orders = multi.Read<Order>().ToList();
    var items = multi.Read<OrderItem>().ToList();

    // Group items by OrderId
    var itemsByOrder = items.GroupBy(i => i.OrderId);
    
    foreach (var order in customer.Orders)
    {
        order.Items = itemsByOrder
            .FirstOrDefault(g => g.Key == order.OrderId)?
            .ToList() ?? new List<OrderItem>();
    }
}
```

**Pros:**
- Simpler SQL
- No duplicate rows
- Often better performance for large datasets

**Cons:**
- More code to assemble objects
- Multiple roundtrips (though batched)

<ProgressCheckpoint section="real-world-examples" xpReward={12} />

## Performance Optimization Strategies

### Strategy 1: Pagination with Multi-Mapping

```csharp
public class PagedResult<T>
{
    public List<T> Items { get; set; }
    public int TotalCount { get; set; }
    public int PageNumber { get; set; }
    public int PageSize { get; set; }
}

public async Task<PagedResult<Customer>> GetCustomersWithOrdersAsync(
    int pageNumber, 
    int pageSize)
{
    var offset = (pageNumber - 1) * pageSize;
    
    var sql = @"
        SELECT COUNT(DISTINCT c.CustomerId) FROM Customers c;
        
        SELECT c.*, o.*
        FROM (
            SELECT * FROM Customers
            ORDER BY CustomerId
            OFFSET @offset ROWS FETCH NEXT @pageSize ROWS ONLY
        ) c
        LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
        ORDER BY c.CustomerId, o.OrderId";

    using (var multi = await connection.QueryMultipleAsync(sql, new { offset, pageSize }))
    {
        var totalCount = await multi.ReadSingleAsync<int>();
        
        var customerDict = new Dictionary<int, Customer>();
        
        var customers = await multi.ReadAsync<Customer, Order, Customer>(
            (customer, order) =>
            {
                if (!customerDict.TryGetValue(customer.CustomerId, out var existing))
                {
                    existing = customer;
                    customerDict.Add(customer.CustomerId, existing);
                }

                if (order != null)
                {
                    existing.Orders.Add(order);
                }

                return existing;
            },
            splitOn: "OrderId"
        );

        return new PagedResult<Customer>
        {
            Items = customerDict.Values.ToList(),
            TotalCount = totalCount,
            PageNumber = pageNumber,
            PageSize = pageSize
        };
    }
}
```

### Strategy 2: Lazy Loading Alternative

Instead of loading everything, provide a method to load related data on demand:

```csharp
public class Customer
{
    private readonly IDbConnection _connection;
    
    public int CustomerId { get; set; }
    public string Name { get; set; }
    
    private List<Order> _orders;
    public List<Order> Orders
    {
        get
        {
            if (_orders == null)
            {
                _orders = LoadOrders();
            }
            return _orders;
        }
    }
    
    private List<Order> LoadOrders()
    {
        return _connection.Query<Order>(
            "SELECT * FROM Orders WHERE CustomerId = @customerId",
            new { customerId = CustomerId }
        ).ToList();
    }
}
```

**Note:** This violates some SOLID principles and isn't recommended for production. Better to use a repository pattern.

<ProgressCheckpoint section="performance-tips" xpReward={10} />

## Architectural Patterns

### Repository Pattern with Multi-Mapping

```csharp
public interface ICustomerRepository
{
    Task<Customer> GetWithOrdersAsync(int customerId);
    Task<IEnumerable<Customer>> GetAllWithOrdersAsync();
}

public class CustomerRepository : ICustomerRepository
{
    private readonly string _connectionString;

    public CustomerRepository(string connectionString)
    {
        _connectionString = connectionString;
    }

    public async Task<Customer> GetWithOrdersAsync(int customerId)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = @"
                SELECT c.*, o.*
                FROM Customers c
                LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
                WHERE c.CustomerId = @customerId";

            var customerDict = new Dictionary<int, Customer>();

            await connection.QueryAsync<Customer, Order, Customer>(
                sql,
                (customer, order) =>
                {
                    if (!customerDict.TryGetValue(customer.CustomerId, out var existing))
                    {
                        existing = customer;
                        customerDict.Add(customer.CustomerId, existing);
                    }

                    if (order != null)
                    {
                        existing.Orders.Add(order);
                    }

                    return existing;
                },
                new { customerId },
                splitOn: "OrderId"
            );

            return customerDict.Values.FirstOrDefault();
        }
    }

    public async Task<IEnumerable<Customer>> GetAllWithOrdersAsync()
    {
        // Similar implementation with dictionary deduplication
        // ...
    }
}
```

### Using with Dependency Injection

```csharp
// Startup.cs or Program.cs
services.AddScoped<ICustomerRepository, CustomerRepository>(sp =>
    new CustomerRepository(Configuration.GetConnectionString("DefaultConnection"))
);

// Controller
public class CustomersController : ControllerBase
{
    private readonly ICustomerRepository _customerRepo;

    public CustomersController(ICustomerRepository customerRepo)
    {
        _customerRepo = customerRepo;
    }

    [HttpGet("{id}/with-orders")]
    public async Task<ActionResult<Customer>> GetWithOrders(int id)
    {
        var customer = await _customerRepo.GetWithOrdersAsync(id);
        
        if (customer == null)
            return NotFound();
            
        return Ok(customer);
    }
}
```

<InfoBox type="success" title="Advanced Mastery Complete! ðŸ†">
You've conquered:
- One-to-many relationship mapping with deduplication
- Multi-level hierarchies (Customer â†’ Order â†’ OrderItem)
- QueryMultiple for complex scenarios
- Pagination strategies with multi-mapping
- Repository pattern integration
- Production-ready architectural approaches

You're now equipped to handle enterprise-level data access scenarios with Dapper!
</InfoBox>

## Performance Benchmarks

Based on real-world scenarios:

| Approach | 1000 Customers + 5000 Orders | Memory | Query Time |
|----------|------------------------------|--------|------------|
| N+1 Queries | 1001 DB calls | 50 MB | ~2000 ms |
| Multi-Mapping JOIN | 1 DB call | 75 MB | ~150 ms |
| QueryMultiple | 2 DB calls | 45 MB | ~120 ms |
| Paginated Multi-Map | 1 DB call (per page) | 8 MB | ~25 ms |

**Recommendation:** Use QueryMultiple or paginated approaches for large datasets.

Continue exploring Dapper's ecosystem with Dapper.Contrib for CRUD operations and Dapper.FluentMap for advanced mapping scenarios!
