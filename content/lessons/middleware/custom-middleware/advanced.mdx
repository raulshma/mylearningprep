# Custom Middleware: Factory Pattern & Advanced Techniques

For complex middleware that needs scoped dependencies or unit testing, the factory-based `IMiddleware` interface provides the cleanest solution.

## Section 1: Inline Middleware - Advanced Patterns

<CustomMiddlewareBuilder mode="advanced" />

### Response Body Modification

```csharp
public class ResponseLoggingMiddleware : IMiddleware
{
    private readonly ILogger<ResponseLoggingMiddleware> _logger;

    public ResponseLoggingMiddleware(ILogger<ResponseLoggingMiddleware> logger)
    {
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var originalBody = context.Response.Body;
        
        using var newBody = new MemoryStream();
        context.Response.Body = newBody;

        await next(context);

        newBody.Seek(0, SeekOrigin.Begin);
        var responseText = await new StreamReader(newBody).ReadToEndAsync();
        
        _logger.LogInformation("Response: {Length} bytes", responseText.Length);

        newBody.Seek(0, SeekOrigin.Begin);
        await newBody.CopyToAsync(originalBody);
        context.Response.Body = originalBody;
    }
}
```

### Request Body Reading

```csharp
public async Task InvokeAsync(HttpContext context, RequestDelegate next)
{
    context.Request.EnableBuffering();
    
    using var reader = new StreamReader(context.Request.Body, leaveOpen: true);
    var body = await reader.ReadToEndAsync();
    context.Request.Body.Position = 0;  // Reset for next middleware
    
    Console.WriteLine($"Request Body: {body}");
    
    await next(context);
}
```

<ProgressCheckpoint section="inline-middleware" xpReward={25} />

---

## Section 2: Convention-Based - Testing and Configuration

### Unit Testing Middleware

```csharp
public class AuditMiddlewareTests
{
    [Fact]
    public async Task InvokeAsync_LogsRequest_ToDatabase()
    {
        // Arrange
        var dbOptions = new DbContextOptionsBuilder<AuditDbContext>()
            .UseInMemoryDatabase("TestDb")
            .Options;
        var db = new AuditDbContext(dbOptions);
        var middleware = new AuditMiddleware(db);
        
        var context = new DefaultHttpContext();
        context.Request.Path = "/api/test";
        
        // Act
        await middleware.InvokeAsync(context, _ => Task.CompletedTask);
        
        // Assert
        var entry = await db.AuditEntries.FirstAsync();
        Assert.Equal("/api/test", entry.Path);
    }
}
```

### Conditional Middleware Activation

```csharp
public class ConditionalMiddlewareStartupFilter : IStartupFilter
{
    private readonly IConfiguration _config;

    public ConditionalMiddlewareStartupFilter(IConfiguration config)
    {
        _config = config;
    }

    public Action<IApplicationBuilder> Configure(Action<IApplicationBuilder> next)
    {
        return app =>
        {
            if (_config.GetValue<bool>("Features:EnableAudit"))
            {
                app.UseMiddleware<AuditMiddleware>();
            }
            next(app);
        };
    }
}

builder.Services.AddTransient<IStartupFilter, ConditionalMiddlewareStartupFilter>();
```

<ProgressCheckpoint section="convention-middleware" xpReward={25} />

---

## Section 3: Factory-Based - Per-Endpoint and Performance

### Per-Endpoint Middleware with Filters

```csharp
public class LoggingEndpointFilter : IEndpointFilter
{
    public async ValueTask<object?> InvokeAsync(
        EndpointFilterInvocationContext context,
        EndpointFilterDelegate next)
    {
        Console.WriteLine($"Before: {context.HttpContext.Request.Path}");
        var result = await next(context);
        Console.WriteLine($"After: {context.HttpContext.Response.StatusCode}");
        return result;
    }
}

app.MapGet("/logged", () => "Hello")
   .AddEndpointFilter<LoggingEndpointFilter>();
```

### Performance Best Practices

```csharp
public class OptimizedMiddleware : IMiddleware
{
    // ✅ Cache compiled expressions
    private static readonly Func<HttpContext, bool> _isApiRequest =
        ctx => ctx.Request.Path.StartsWithSegments("/api");

    // ✅ Pre-allocate buffers
    private static readonly byte[] _notFoundBytes = 
        Encoding.UTF8.GetBytes("Not Found");

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        if (_isApiRequest(context))
        {
            // Handle API requests
        }

        await next(context);

        // ✅ Write bytes directly
        if (context.Response.StatusCode == 404)
        {
            await context.Response.Body.WriteAsync(_notFoundBytes);
        }
    }
}
```

### Key Takeaways

| Pattern | Use Case |
| :------ | :------- |
| **IMiddleware** | Per-request instances with scoped DI |
| **Body capture** | Enable buffering, reset position |
| **Endpoint filters** | Per-endpoint logic |
| **Performance** | Cache expressions, pre-allocate buffers |

<ProgressCheckpoint section="factory-middleware" xpReward={25} />
