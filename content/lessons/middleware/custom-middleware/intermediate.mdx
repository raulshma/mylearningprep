# Custom Middleware: Class-Based Approach

While inline middleware is quick, production applications benefit from **class-based middleware**. This separates concerns, enables dependency injection, and makes testing easier.

## Section 1: Inline Middleware Patterns

<CustomMiddlewareBuilder mode="intermediate" />

### Three Ways to Write Middleware

| **Approach** | **Use When** | **DI Support** |
| :----------- | :----------- | :------------- |
| Inline (`Use()`) | Quick prototyping | Via `HttpContext.RequestServices` |
| Convention-based | Most production scenarios | Constructor (Singleton only) |
| Factory (`IMiddleware`) | Need scoped dependencies | Constructor (any lifetime) |

### Inline with Services

```csharp
app.Use(async (context, next) =>
{
    var logger = context.RequestServices
        .GetRequiredService<ILogger<Program>>();
    
    logger.LogInformation("Request: {Path}", context.Request.Path);
    await next();
});
```

<ProgressCheckpoint section="inline-middleware" xpReward={16} />

---

## Section 2: Convention-Based Middleware

### The Standard Pattern

```csharp
public class RequestTimingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestTimingMiddleware> _logger;

    public RequestTimingMiddleware(
        RequestDelegate next, 
        ILogger<RequestTimingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        
        await _next(context);
        
        stopwatch.Stop();
        _logger.LogInformation(
            "{Method} {Path} completed in {Elapsed}ms",
            context.Request.Method,
            context.Request.Path,
            stopwatch.ElapsedMilliseconds);
    }
}
```

### Middleware with Options

```csharp
public class RateLimitOptions
{
    public int MaxRequests { get; set; } = 100;
    public TimeSpan Window { get; set; } = TimeSpan.FromMinutes(1);
}

public class SimpleRateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private readonly RateLimitOptions _options;

    public SimpleRateLimitMiddleware(
        RequestDelegate next, 
        IOptions<RateLimitOptions> options)
    {
        _next = next;
        _options = options.Value;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Rate limiting logic using _options
        await _next(context);
    }
}

// Usage with options
app.UseMiddleware<SimpleRateLimitMiddleware>();
```

### Scoped Services Warning

<InfoBox type="warning">
  Convention-based middleware is created **once at startup** (singleton). Inject scoped services in `InvokeAsync`, not the constructor!
</InfoBox>

```csharp
public class CorrectMiddleware
{
    private readonly RequestDelegate _next;

    public CorrectMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    // Scoped services injected HERE, per-request
    public async Task InvokeAsync(
        HttpContext context, 
        MyDbContext db,
        IUserService userService)
    {
        // db and userService are fresh for each request!
        await _next(context);
    }
}
```

<ProgressCheckpoint section="convention-middleware" xpReward={17} />

---

## Section 3: Factory-Based Middleware

### IMiddleware Interface

For scoped dependencies in the constructor, use `IMiddleware`:

```csharp
public class AuditMiddleware : IMiddleware
{
    private readonly AuditDbContext _db;  // Scoped - works!

    public AuditMiddleware(AuditDbContext db)
    {
        _db = db;
    }

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var entry = new AuditEntry
        {
            Path = context.Request.Path,
            Timestamp = DateTime.UtcNow
        };

        await next(context);
        
        entry.StatusCode = context.Response.StatusCode;
        _db.AuditEntries.Add(entry);
        await _db.SaveChangesAsync();
    }
}

// Must register in DI
builder.Services.AddScoped<AuditMiddleware>();
app.UseMiddleware<AuditMiddleware>();
```

### Key Takeaways

| Pattern | DI Support | Lifetime |
| :------ | :--------- | :------- |
| **Inline** | Via RequestServices | Per-request |
| **Convention** | Constructor (singleton) | Singleton |
| **IMiddleware** | Constructor (any) | Per-request |

<ProgressCheckpoint section="factory-middleware" xpReward={17} />
