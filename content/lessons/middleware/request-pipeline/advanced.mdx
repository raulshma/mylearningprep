# Deep Dive: Request Pipeline Architecture

At its core, the ASP.NET Core request pipeline is a chain of **request delegates** built using the **Chain of Responsibility** pattern.

## Section 1: Pipeline Overview - The RequestDelegate

### Understanding RequestDelegate

Every middleware ultimately works with a `RequestDelegate`:

```csharp
public delegate Task RequestDelegate(HttpContext context);
```

### How IApplicationBuilder Works

```csharp
public interface IApplicationBuilder
{
    IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware);
    RequestDelegate Build();
}
```

Each `Use()` adds a wrapper function that receives the next delegate:

```csharp
// Simplified internal implementation
public class ApplicationBuilder : IApplicationBuilder
{
    private readonly List<Func<RequestDelegate, RequestDelegate>> _components = new();
    
    public RequestDelegate Build()
    {
        RequestDelegate app = context =>
        {
            context.Response.StatusCode = 404;
            return Task.CompletedTask;
        };
        
        // Build chain in REVERSE order
        for (var i = _components.Count - 1; i >= 0; i--)
        {
            app = _components[i](app);
        }
        
        return app;
    }
}
```

<InfoBox type="important">
  **Key Insight:** The chain is built in **reverse order**. The first middleware you add wraps all subsequent middleware.
</InfoBox>

<MiddlewarePipelineSimulator mode="advanced" />

<ProgressCheckpoint section="pipeline-overview" xpReward={20} />

---

## Section 2: Pipeline Flow - Advanced Branching

### UseWhen — Non-Branching Conditional Middleware

Unlike `MapWhen`, `UseWhen` **rejoins** the main pipeline:

```csharp
app.UseWhen(
    context => context.Request.Path.StartsWithSegments("/api"),
    apiApp =>
    {
        apiApp.UseMiddleware<ApiLoggingMiddleware>();
        // Then continues to main pipeline!
    }
);

// This runs for ALL requests (including /api/*)
app.UseAuthentication();
```

### Request Features Architecture

`HttpContext` provides access to replaceable **features**:

```csharp
app.Use(async (context, next) =>
{
    // Access low-level features
    var requestFeature = context.Features.Get<IHttpRequestFeature>();
    
    // Replace response body to capture output
    var originalBody = context.Response.Body;
    using var newBody = new MemoryStream();
    context.Response.Body = newBody;
    
    await next();
    
    // Read captured response
    newBody.Seek(0, SeekOrigin.Begin);
    var responseText = await new StreamReader(newBody).ReadToEndAsync();
    
    // Restore and copy
    newBody.Seek(0, SeekOrigin.Begin);
    await newBody.CopyToAsync(originalBody);
    context.Response.Body = originalBody;
});
```

<ProgressCheckpoint section="pipeline-flow" xpReward={20} />

---

## Section 3: Pipeline Order - Endpoint Routing Deep Dive

### Endpoint Routing Separates Matching from Execution

```csharp
app.UseRouting();  // Matches route, sets endpoint

// Middleware here can inspect the selected endpoint!
app.Use(async (context, next) =>
{
    var endpoint = context.GetEndpoint();
    if (endpoint != null)
    {
        var authorize = endpoint.Metadata.GetMetadata<AuthorizeAttribute>();
        Console.WriteLine($"Endpoint: {endpoint.DisplayName}");
    }
    await next();
});

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();  // Executes matched endpoint
```

### Performance Considerations

#### Avoid Unnecessary Async

```csharp
// ❌ Unnecessary async overhead
app.Use(async (context, next) =>
{
    context.Response.Headers.Add("X-Custom", "value");
    await next();
});

// ✅ More efficient
app.Use((context, next) =>
{
    context.Response.Headers.Add("X-Custom", "value");
    return next();  // Returns Task directly
});
```

#### Early Short-Circuiting

```csharp
// ✅ Static files first - short-circuits most requests
app.UseStaticFiles();

// Heavy middleware runs less often
app.UseAuthentication();
app.UseAuthorization();
```

### Testing Middleware

```csharp
[Fact]
public async Task Middleware_AddsCustomHeader()
{
    var builder = new WebHostBuilder()
        .Configure(app =>
        {
            app.UseMiddleware<CustomHeaderMiddleware>();
            app.Run(async ctx => await ctx.Response.WriteAsync("OK"));
        });
    
    using var server = new TestServer(builder);
    using var client = server.CreateClient();
    
    var response = await client.GetAsync("/");
    
    Assert.True(response.Headers.Contains("X-Custom-Header"));
}
```

### Key Takeaways

| Concept | Description |
| :------ | :---------- |
| **RequestDelegate** | Core building block of pipeline |
| **Reverse Build** | First middleware wraps all others |
| **UseWhen** | Conditional middleware that rejoins |
| **Features** | Replaceable HttpContext components |
| **Endpoint Routing** | Separates matching from execution |

<ProgressCheckpoint section="pipeline-order" xpReward={20} />
