# Variables & Data Types in C#

Understanding C#'s type system at a deep level is essential for building high-performance .NET applications. Let's explore the memory layout, boxing/unboxing implications, and advanced type patterns.

---

## Section 1: Memory Layout - Stack vs Heap

The CLR manages memory in two regions:

**Stack**:
- Fast allocation/deallocation (LIFO)
- Stores value types and reference pointers
- Per-thread, limited size (~1MB default)

**Heap**:
- Dynamic allocation, garbage collected
- Stores reference type instances
- Shared across threads, larger

```csharp
public void MemoryDemo()
{
    // Stack allocation
    int x = 42;           // 4 bytes on stack
    Point p = new(1, 2);  // struct on stack (if local)

    // Heap allocation
    string s = "Hello";   // Reference on stack, string on heap
    int[] arr = [1, 2];   // Reference on stack, array on heap

    // Stack frame destroyed when method returns
}
```

**Key takeaways:**
- Value types (`int`, `struct`) live on the stack when local - extremely fast allocation
- Reference types allocate on the heap - the variable holds only a pointer

<ProgressCheckpoint section="intro-variables" xpReward={15} />

---

## Section 2: Boxing and Unboxing

Boxing wraps value types in object references - a performance concern:

```csharp
// Boxing - value type → object (heap allocation!)
int value = 42;
object boxed = value;  // Boxing occurs here

// Unboxing - object → value type (type check + copy)
int unboxed = (int)boxed;

// Performance trap: ArrayList boxes everything
ArrayList list = new();
for (int i = 0; i < 1000000; i++)
{
    list.Add(i);  // Boxing 1 million times!
}

// Solution: Generic collections avoid boxing
List<int> genericList = new();  // No boxing!
```

**Performance implications:**
- Boxing allocates heap memory, copies value, stores type info - ~20x slower!
- Unboxing requires runtime type check, then copies value back to stack
- Non-generic collections cause boxing - 1M allocations = GC pressure!
- `List<int>` stores ints directly, no boxing overhead

<ProgressCheckpoint section="common-types" xpReward={15} />

---

## Section 3: Span&lt;T&gt; and Memory&lt;T&gt;

Modern C# offers stack-only buffers for high-performance scenarios:

```csharp
// Span wraps existing memory - no allocation!
int[] array = [1, 2, 3, 4, 5];
Span<int> span = array.AsSpan();

// Slice without copying
Span<int> slice = span.Slice(1, 3);  // [2, 3, 4]
slice[0] = 99;  // Modifies original array!

// Stack allocation with stackalloc
Span<byte> buffer = stackalloc byte[256];
buffer[0] = 42;  // No heap allocation!

// String slicing without allocation
ReadOnlySpan<char> chars = "Hello World".AsSpan();
ReadOnlySpan<char> word = chars.Slice(0, 5);  // "Hello"
```

### ref, in, and out Parameters

Parameter modifiers for performance-critical code:

```csharp
public struct LargeStruct  // 64+ bytes
{
    public long A, B, C, D, E, F, G, H;
}

// Pass by value - COPIES entire struct!
void ProcessByValue(LargeStruct data) { }

// Pass by reference - no copy, allows modification
void ProcessByRef(ref LargeStruct data) { data.A = 1; }

// Pass by readonly reference - no copy, no modification
void ProcessByIn(in LargeStruct data)
{
    // data.A = 1;  // Compile error!
    Console.WriteLine(data.A);
}

// Out parameter - must assign before return
bool TryGetValue(out int result)
{
    result = 42;  // Must assign!
    return true;
}
```

<ProgressCheckpoint section="type-conversion" xpReward={15} />

---

## Section 4: Records and Advanced Patterns

### Records and Value Equality

C# 9+ records provide value-based equality semantics:

```csharp
// Reference record (class-based)
public record Person(string Name, int Age);

// Value record (struct-based)
public readonly record struct Point(int X, int Y);

// Usage
var p1 = new Person("Alice", 30);
var p2 = new Person("Alice", 30);
Console.WriteLine(p1 == p2);  // True! Value equality

// With-expressions for immutable updates
var p3 = p1 with { Age = 31 };

// Deconstruction
var (name, age) = p1;
```

### Custom Conversions

Define implicit and explicit conversions for custom types:

```csharp
public readonly struct Celsius
{
    public double Value { get; }
    public Celsius(double value) => Value = value;

    // Implicit from double
    public static implicit operator Celsius(double d)
        => new(d);

    // Explicit to Fahrenheit (lossy conceptually)
    public static explicit operator double(Celsius c)
        => c.Value * 9 / 5 + 32;
}

// Usage
Celsius temp = 100;           // Implicit conversion
double fahrenheit = (double)temp;  // Explicit: 212
```

### Performance Considerations

| Pattern         | When to Use                       | Avoid When                       |
| :-------------- | :-------------------------------- | :------------------------------- |
| `struct`        | Small (&lt;16 bytes), short-lived | Frequent copying needed          |
| `class`         | Complex, shared, long-lived       | Simple data containers           |
| `record class`  | Immutable reference data          | Needs traditional class features |
| `record struct` | Small immutable value data        | Large data structures            |
| `Span<T>`       | High-perf buffer operations       | Need to store on heap            |
| `ref returns`   | Return large data efficiently     | Simple value returns             |

<InfoBox type="tip" title="Key Takeaways">
- Stack allocation is fast; heap allocation triggers GC
- Boxing is expensive - use generic collections
- `Span<T>` enables zero-allocation slicing
- Use `in` for large readonly structs
- Records provide value equality with minimal code
- Choose struct vs class based on size and usage patterns
</InfoBox>

<ProgressCheckpoint section="advanced-types" xpReward={15} />
