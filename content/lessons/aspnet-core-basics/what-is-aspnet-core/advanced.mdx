# What is ASP.NET Core?

ASP.NET Core represents a fundamental architectural shift from its predecessor, embracing modularity, cross-platform support, and cloud-native patterns. Let's explore the internals that make it one of the most performant web frameworks available.

---

## Section 1: Introduction to ASP.NET Core

### Architectural Philosophy

ASP.NET Core was designed with these core principles:

1. **Modularity**: Everything is a NuGet package, including the framework itself
2. **Dependency Injection**: First-class DI container built into the framework
3. **Middleware Pipeline**: Composable request processing
4. **Cross-Platform**: Single codebase runs on Windows, Linux, macOS
5. **Cloud-Native**: Designed for containers, orchestration, and horizontal scaling

### Evolution from ASP.NET Framework

```
ASP.NET Framework (2002-2019)
├── Monolithic System.Web assembly
├── Tightly coupled to IIS
├── Windows-only
└── Global.asax, Web.config

ASP.NET Core (2016-present)
├── Modular NuGet packages
├── Kestrel + reverse proxy pattern
├── Cross-platform (.NET runtime)
└── Program.cs, appsettings.json
```

### The .NET Ecosystem

```
.NET 8 (Current LTS)
├── ASP.NET Core (Web framework)
├── Entity Framework Core (ORM)
├── Blazor (Web UI with C#)
├── MAUI (Cross-platform UI)
├── ML.NET (Machine learning)
└── Orleans (Distributed systems)
```

<AspNetCoreIntroVisualizer mode="advanced" />

<ProgressCheckpoint section="intro-aspnet-core" xpReward={20} />

---

## Section 2: ASP.NET Core Overview

### The Generic Host

ASP.NET Core is built on the **Generic Host** (`IHost`), which provides:

```csharp
var builder = WebApplication.CreateBuilder(args);

// WebApplicationBuilder provides:
// - IHostBuilder: App lifetime, DI, configuration
// - IWebHostBuilder: Kestrel, server configuration
// - IServiceCollection: Service registration
// - ConfigurationManager: Configuration sources

// The builder pattern allows fluent configuration
builder.Services.AddControllers();
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("Default")));

var app = builder.Build();

// WebApplication is both IHost and IApplicationBuilder
app.UseRouting();
app.MapControllers();

await app.RunAsync(); // Starts host and blocks
```

### Host Lifetime Events

```csharp
public class LifetimeEventsHostedService : IHostedService
{
    private readonly IHostApplicationLifetime _lifetime;
    private readonly ILogger<LifetimeEventsHostedService> _logger;

    public LifetimeEventsHostedService(
        IHostApplicationLifetime lifetime,
        ILogger<LifetimeEventsHostedService> logger)
    {
        _lifetime = lifetime;
        _logger = logger;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _lifetime.ApplicationStarted.Register(() =>
            _logger.LogInformation("Application started"));
        
        _lifetime.ApplicationStopping.Register(() =>
            _logger.LogInformation("Application stopping..."));
        
        _lifetime.ApplicationStopped.Register(() =>
            _logger.LogInformation("Application stopped"));
        
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken) 
        => Task.CompletedTask;
}
```

### Middleware Pipeline Deep Dive

The middleware pipeline is implemented as a **Russian doll pattern**:

```csharp
// Each middleware wraps the next
public class TimingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<TimingMiddleware> _logger;

    public TimingMiddleware(RequestDelegate next, ILogger<TimingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        
        // Before next middleware
        _logger.LogInformation("Request starting: {Path}", context.Request.Path);
        
        await _next(context); // Call next middleware
        
        // After next middleware (response flowing back)
        stopwatch.Stop();
        _logger.LogInformation("Request completed in {ElapsedMs}ms", 
            stopwatch.ElapsedMilliseconds);
    }
}

// Register middleware
app.UseMiddleware<TimingMiddleware>();
```

### Endpoint Routing Architecture

ASP.NET Core 3.0+ separates route matching from endpoint execution:

```csharp
// Phase 1: UseRouting() - Matches the endpoint
app.UseRouting();

// Phase 2: Middleware can inspect matched endpoint
app.Use(async (context, next) =>
{
    var endpoint = context.GetEndpoint();
    if (endpoint != null)
    {
        var metadata = endpoint.Metadata.GetMetadata<AuthorizeAttribute>();
        // Inspect endpoint metadata
    }
    await next();
});

app.UseAuthentication();
app.UseAuthorization();

// Phase 3: Endpoint executes
app.MapControllers();
app.MapRazorPages();
app.MapHub<ChatHub>("/chat");
```

<ProgressCheckpoint section="aspnet-core-overview" xpReward={20} />

---

## Section 3: ASP.NET Core Internals

### Kestrel Architecture

Kestrel is a **high-performance, cross-platform HTTP server**:

```csharp
builder.WebHost.ConfigureKestrel((context, serverOptions) =>
{
    // Connection limits
    serverOptions.Limits.MaxConcurrentConnections = 100;
    serverOptions.Limits.MaxConcurrentUpgradedConnections = 100;
    serverOptions.Limits.MaxRequestBodySize = 10 * 1024 * 1024;
    serverOptions.Limits.MinRequestBodyDataRate = new MinDataRate(
        bytesPerSecond: 100, gracePeriod: TimeSpan.FromSeconds(10));
    
    // HTTP/2 settings
    serverOptions.Limits.Http2.MaxStreamsPerConnection = 100;
    serverOptions.Limits.Http2.HeaderTableSize = 4096;
    serverOptions.Limits.Http2.MaxFrameSize = 16384;
    
    // Listen on multiple endpoints
    serverOptions.ListenAnyIP(5000); // HTTP
    serverOptions.ListenAnyIP(5001, listenOptions =>
    {
        listenOptions.UseHttps(httpsOptions =>
        {
            httpsOptions.SslProtocols = SslProtocols.Tls12 | SslProtocols.Tls13;
        });
        listenOptions.Protocols = HttpProtocols.Http1AndHttp2AndHttp3;
    });
    
    // Unix socket for reverse proxy
    serverOptions.ListenUnixSocket("/tmp/kestrel.sock");
});
```

### DI Container Internals

The built-in container uses **service descriptors**:

```csharp
// Service descriptor structure
public class ServiceDescriptor
{
    public Type ServiceType { get; }
    public Type? ImplementationType { get; }
    public object? ImplementationInstance { get; }
    public Func<IServiceProvider, object>? ImplementationFactory { get; }
    public ServiceLifetime Lifetime { get; }
}

// Registration methods create descriptors
services.AddScoped<IUserService, UserService>();
// Creates: ServiceDescriptor(typeof(IUserService), typeof(UserService), Scoped)

services.AddSingleton<ICacheService>(sp => new RedisCacheService(
    sp.GetRequiredService<IConfiguration>()["Redis:ConnectionString"]));
// Creates: ServiceDescriptor with factory function
```

### Service Resolution Flow

```csharp
// 1. Request service from container
var userService = serviceProvider.GetRequiredService<IUserService>();

// Internal resolution process:
// 1. Find ServiceDescriptor for IUserService
// 2. Check lifetime:
//    - Singleton: Check root container cache
//    - Scoped: Check current scope cache
//    - Transient: Always create new
// 3. If not cached, create instance:
//    - Find constructor with most resolvable parameters
//    - Recursively resolve all constructor parameters
//    - Create instance via compiled expression tree
// 4. Cache if Singleton or Scoped
// 5. Return instance
```

### Configuration Providers

```csharp
// Default configuration sources (in order)
builder.Configuration
    .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
    .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true)
    .AddUserSecrets<Program>(optional: true) // Development only
    .AddEnvironmentVariables()
    .AddCommandLine(args);

// Custom configuration provider
public class DatabaseConfigurationProvider : ConfigurationProvider
{
    public override void Load()
    {
        using var db = new ConfigDbContext();
        Data = db.Settings.ToDictionary(s => s.Key, s => s.Value);
    }
}

// Options pattern for strongly-typed config
builder.Services.Configure<JwtSettings>(
    builder.Configuration.GetSection("Jwt"));

builder.Services.AddOptions<SmtpSettings>()
    .Bind(builder.Configuration.GetSection("Smtp"))
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

### Performance Optimizations

ASP.NET Core achieves high performance through:

```csharp
// 1. Object pooling
builder.Services.AddSingleton<ObjectPoolProvider, DefaultObjectPoolProvider>();
builder.Services.AddSingleton(sp =>
{
    var provider = sp.GetRequiredService<ObjectPoolProvider>();
    return provider.Create(new StringBuilderPooledObjectPolicy());
});

// 2. Span<T> for zero-allocation parsing
public static int ParseInt(ReadOnlySpan<char> span)
{
    return int.Parse(span);
}

// 3. ArrayPool for temporary buffers
var buffer = ArrayPool<byte>.Shared.Rent(4096);
try
{
    // Use buffer
}
finally
{
    ArrayPool<byte>.Shared.Return(buffer);
}

// 4. Response compression
builder.Services.AddResponseCompression(options =>
{
    options.EnableForHttps = true;
    options.Providers.Add<BrotliCompressionProvider>();
    options.Providers.Add<GzipCompressionProvider>();
});

// 5. Output caching (.NET 7+)
builder.Services.AddOutputCache(options =>
{
    options.AddBasePolicy(builder => builder.Expire(TimeSpan.FromMinutes(5)));
    options.AddPolicy("Aggressive", builder => 
        builder.Expire(TimeSpan.FromHours(1)).Tag("static"));
});
```

### Benchmark Results

| Framework | Requests/sec | Latency (avg) |
|:----------|:-------------|:--------------|
| ASP.NET Core | 7,014,988 | 0.09ms |
| Go (fasthttp) | 6,162,556 | 0.10ms |
| Node.js | 1,234,567 | 0.51ms |
| Spring Boot | 892,345 | 0.71ms |

*Source: TechEmpower Round 21 Benchmarks*

<ProgressCheckpoint section="aspnet-core-internals" xpReward={20} />
