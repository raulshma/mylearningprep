# Advanced Configuration Patterns

Master the configuration system with custom providers, validation, hot reload, and production-ready patterns for managing secrets and complex configurations.

---

## Section 1: Configuration Architecture

### How Configuration Providers Work

Configuration in ASP.NET Core is built on a provider model where each source implements `IConfigurationProvider`:

<ConfigurationVisualizer mode="advanced" />

```csharp
// The configuration builder aggregates multiple providers
var builder = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .AddJsonFile($"appsettings.{env}.json", optional: true, reloadOnChange: true)
    .AddEnvironmentVariables()
    .AddCommandLine(args);

IConfiguration configuration = builder.Build();
```

### Configuration Change Tokens

React to configuration changes at runtime:

```csharp
// React to any configuration change
var changeToken = builder.Configuration.GetReloadToken();

changeToken.RegisterChangeCallback(state =>
{
    Console.WriteLine("Configuration has been reloaded!");
}, null);

// Enable auto-reload for JSON files
builder.Configuration.AddJsonFile("appsettings.json", 
    optional: false, 
    reloadOnChange: true);  // Monitor for file changes
```

### Custom Configuration Provider

```csharp
public class DatabaseConfigurationSource : IConfigurationSource
{
    public string ConnectionString { get; set; }

    public IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        return new DatabaseConfigurationProvider(this);
    }
}

public class DatabaseConfigurationProvider : ConfigurationProvider
{
    private readonly DatabaseConfigurationSource _source;

    public DatabaseConfigurationProvider(DatabaseConfigurationSource source)
    {
        _source = source;
    }

    public override void Load()
    {
        using var connection = new SqlConnection(_source.ConnectionString);
        connection.Open();
        
        var command = new SqlCommand("SELECT [Key], [Value] FROM AppConfig", connection);
        using var reader = command.ExecuteReader();
        
        Data = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        
        while (reader.Read())
        {
            Data[reader.GetString(0)] = reader.GetString(1);
        }
    }
}
```

<ProgressCheckpoint section="config-basics" xpReward={20} />

---

## Section 2: Options Pattern Deep Dive

### IOptions vs IOptionsSnapshot vs IOptionsMonitor

```csharp
public class MyService
{
    // IOptions<T> - Singleton, values never change after startup
    public MyService(IOptions<EmailSettings> options)
    {
        var settings = options.Value; // Same instance always
    }
}

public class RequestScopedService
{
    // IOptionsSnapshot<T> - Scoped, re-reads config per request
    public RequestScopedService(IOptionsSnapshot<EmailSettings> options)
    {
        var settings = options.Value; // May be different per request
    }
}

public class BackgroundService
{
    // IOptionsMonitor<T> - Singleton with change notifications
    public BackgroundService(IOptionsMonitor<EmailSettings> options)
    {
        var settings = options.CurrentValue;
        
        // React to configuration changes
        options.OnChange(newSettings =>
        {
            Console.WriteLine($"Config changed! New server: {newSettings.SmtpServer}");
        });
    }
}
```

### Named Options

```csharp
// Register multiple instances with names
builder.Services.Configure<EmailSettings>("primary", config =>
{
    config.SmtpServer = "smtp.primary.com";
});
builder.Services.Configure<EmailSettings>("backup", config =>
{
    config.SmtpServer = "smtp.backup.com";
});

// Access by name
public class EmailService
{
    private readonly EmailSettings _primarySettings;
    private readonly EmailSettings _backupSettings;

    public EmailService(IOptionsSnapshot<EmailSettings> options)
    {
        _primarySettings = options.Get("primary");
        _backupSettings = options.Get("backup");
    }
}
```

### Options Validation

```csharp
// Validate at startup (fail fast)
builder.Services.AddOptions<EmailSettings>()
    .BindConfiguration("EmailSettings")
    .ValidateDataAnnotations()
    .ValidateOnStart();  // Validate immediately at startup

// Using data annotations
public class EmailSettings
{
    [Required]
    [EmailAddress]
    public string FromAddress { get; set; } = string.Empty;
    
    [Required]
    public string SmtpServer { get; set; } = string.Empty;
    
    [Range(1, 65535)]
    public int Port { get; set; } = 587;
}

// Custom validation logic
builder.Services.AddOptions<EmailSettings>()
    .BindConfiguration("EmailSettings")
    .Validate(settings =>
    {
        return !string.IsNullOrEmpty(settings.SmtpServer) 
            && settings.Port > 0;
    }, "Invalid email configuration");
```

<ProgressCheckpoint section="config-intermediate" xpReward={20} />

---

## Section 3: Production Secret Management

### Azure Key Vault Integration

```csharp
// Install: Azure.Extensions.AspNetCore.Configuration.Secrets

builder.Configuration.AddAzureKeyVault(
    new Uri("https://mykeyvault.vault.azure.net/"),
    new DefaultAzureCredential());

// Secrets are accessed like any other configuration
string apiKey = builder.Configuration["MyApiKey"];
```

### Secret Transformation

```csharp
// Key Vault secrets use "--" instead of ":" for hierarchy
// Secret name: "EmailSettings--Password"
// Accessed as: Configuration["EmailSettings:Password"]

builder.Configuration.AddAzureKeyVault(
    new Uri(vaultUri),
    new DefaultAzureCredential(),
    new AzureKeyVaultConfigurationOptions
    {
        Manager = new KeyVaultSecretManager()
    });
```

### Post-Configuration

```csharp
// Modify options after all other configuration
builder.Services.PostConfigure<EmailSettings>(settings =>
{
    // Ensure port is always positive
    if (settings.Port <= 0)
    {
        settings.Port = 587;
    }
    
    // Default from address if not set
    if (string.IsNullOrEmpty(settings.FromAddress))
    {
        settings.FromAddress = "noreply@default.com";
    }
});
```

### Binding Complex Types

```csharp
// Configuration
{
  "Features": {
    "EnableCache": true,
    "CacheSettings": {
      "ExpirationMinutes": 30,
      "AllowedTypes": ["User", "Product", "Order"]
    }
  }
}

// Bind to complex types
public class FeatureSettings
{
    public bool EnableCache { get; set; }
    public CacheSettings CacheSettings { get; set; }
}

public class CacheSettings
{
    public int ExpirationMinutes { get; set; }
    public List<string> AllowedTypes { get; set; } = new();
}

// Register
builder.Services.Configure<FeatureSettings>(
    builder.Configuration.GetSection("Features"));
```

### Key Takeaways

<InfoBox type="tip">
**Remember:**
- Use `IOptionsMonitor<T>` for singleton services that need to react to config changes
- Use `IOptionsSnapshot<T>` for scoped services that need fresh config per request
- Validate options at startup with `ValidateOnStart()` to fail fast
- Use Azure Key Vault or similar for production secrets
- Named options allow multiple configurations of the same type
</InfoBox>

<ProgressCheckpoint section="config-advanced" xpReward={20} />
