# Program.cs & Application Startup

In modern ASP.NET Core (.NET 6+), application configuration is streamlined into a single `Program.cs` file using the **minimal hosting model**. Let's explore how services are registered and the request pipeline is configured.

---

## Section 1: Program Basics

### The Minimal Hosting Model

The minimal hosting model combines what used to be separate `Program.cs` and `Startup.cs` files:

```csharp
var builder = WebApplication.CreateBuilder(args);

// === SERVICE REGISTRATION ===
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// === MIDDLEWARE PIPELINE ===
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

### WebApplicationBuilder

The `WebApplicationBuilder` provides access to:

| Property | Purpose |
|:---------|:--------|
| `Services` | DI container for registering services |
| `Configuration` | Access appsettings.json and other config |
| `Environment` | Check Development/Production/etc. |
| `Logging` | Configure logging providers |
| `Host` | Access IHostBuilder for advanced config |
| `WebHost` | Access IWebHostBuilder for Kestrel config |

```csharp
var builder = WebApplication.CreateBuilder(args);

// Access configuration
var connectionString = builder.Configuration.GetConnectionString("Default");

// Check environment
if (builder.Environment.IsDevelopment())
{
    builder.Services.AddDatabaseDeveloperPageExceptionFilter();
}

// Configure logging
builder.Logging.AddConsole();
builder.Logging.SetMinimumLevel(LogLevel.Debug);
```

<ProgressCheckpoint section="program-basics" xpReward={15} />

---

## Section 2: Services and Dependency Injection

### Service Lifetimes

When registering services, choose the appropriate lifetime:

```csharp
// Singleton: One instance shared throughout the app's lifetime
builder.Services.AddSingleton<ICacheService, CacheService>();

// Scoped: One instance per HTTP request
builder.Services.AddScoped<IUserRepository, UserRepository>();

// Transient: New instance every time it's requested
builder.Services.AddTransient<IEmailSender, EmailSender>();
```

| Lifetime | When to Use | Example |
|:---------|:------------|:--------|
| **Singleton** | Stateless, thread-safe services | Caching, configuration |
| **Scoped** | Per-request state | DbContext, user services |
| **Transient** | Lightweight, stateless | Email sender, validators |

### Registering Custom Services

```csharp
var builder = WebApplication.CreateBuilder(args);

// Interface to implementation
builder.Services.AddScoped<IUserService, UserService>();

// With factory
builder.Services.AddScoped<IEmailService>(sp =>
{
    var config = sp.GetRequiredService<IConfiguration>();
    return new SmtpEmailService(config["Smtp:Host"]);
});

// DbContext
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("Default")));

// HttpClient
builder.Services.AddHttpClient<IWeatherClient, WeatherClient>(client =>
{
    client.BaseAddress = new Uri("https://api.weather.com");
});
```

<ProgressCheckpoint section="program-intermediate" xpReward={15} />

---

## Section 3: Middleware Pipeline

### How Middleware Works

Middleware components form a **pipeline** that processes HTTP requests:

<MiddlewarePipelineSimulator mode="intermediate" />

Each middleware can:
- Handle the request and short-circuit the pipeline
- Pass the request to the next middleware
- Perform work before AND after the next middleware

### Common Middleware Order

Order matters! Here's the recommended sequence:

```csharp
var app = builder.Build();

// 1. Exception handling (first to catch all errors)
app.UseExceptionHandler("/Error");

// 2. HSTS (production only)
if (!app.Environment.IsDevelopment())
{
    app.UseHsts();
}

// 3. HTTPS redirection
app.UseHttpsRedirection();

// 4. Static files (CSS, JS, images)
app.UseStaticFiles();

// 5. Routing (match URL to endpoint)
app.UseRouting();

// 6. CORS (if needed)
app.UseCors("AllowAll");

// 7. Authentication (who are you?)
app.UseAuthentication();

// 8. Authorization (what can you do?)
app.UseAuthorization();

// 9. Endpoint execution
app.MapControllers();

app.Run();
```

### Minimal APIs vs Controllers

In .NET 6+, you can define endpoints directly in Program.cs:

```csharp
// Minimal API approach
app.MapGet("/hello", () => "Hello World!");

app.MapGet("/users/{id}", async (int id, IUserService service) =>
{
    var user = await service.GetByIdAsync(id);
    return user is null ? Results.NotFound() : Results.Ok(user);
});

app.MapPost("/users", async (CreateUserDto dto, IUserService service) =>
{
    var user = await service.CreateAsync(dto);
    return Results.Created($"/users/{user.Id}", user);
});

// Traditional Controllers
app.MapControllers();  // Uses [ApiController] classes
```

### Best Practices

<InfoBox type="tip">
**Program.cs Best Practices:**
- Keep Program.cs clean - move complex registration to extension methods
- Use environment checks for dev-only middleware
- Follow the recommended middleware order
- Use Minimal APIs for simple endpoints, Controllers for complex ones
</InfoBox>

<ProgressCheckpoint section="program-advanced" xpReward={10} />
