# Advanced REST: HATEOAS and Richardson Maturity Model

While many APIs claim to be "RESTful," true REST involves more than just using GET and POST. Let's explore the advanced concepts that separate a basic "Web API" from a truly "RESTful API."

<InfoBox type="info">
  Most production APIs operate at Level 2 of the Richardson Maturity Model. Level 3 (HATEOAS) is the theoretical ideal but adds significant complexity. Understanding all levels helps you make informed architectural decisions.
</InfoBox>

## The Richardson Maturity Model üìä

Leonard Richardson analyzed web service designs and created a maturity model with 4 levels. Each level builds on the previous one:

### Level 0: The Swamp of POX (Plain Old XML) üå´Ô∏è

**Characteristics:**
- Single endpoint for everything
- HTTP used only as a transport mechanism
- All operations use POST
- No use of HTTP features (methods, status codes, headers)

**Example:**
```csharp
// Everything goes to one endpoint
[HttpPost("api")]
public IActionResult HandleRequest([FromBody] XmlCommand command)
{
    switch (command.Action)
    {
        case "GetUser":
            return Ok(GetUser(command.UserId));
        case "CreateUser":
            return Ok(CreateUser(command.UserData));
        case "DeleteUser":
            return Ok(DeleteUser(command.UserId));
        default:
            return BadRequest("Unknown action");
    }
}
```

**Request Example:**
```xml
POST /api
<command>
  <action>GetUser</action>
  <userId>123</userId>
</command>
```

**Problems:**
- No caching (everything is POST)
- No standard error handling
- Difficult to understand and document
- Can't leverage HTTP infrastructure (proxies, CDNs)

<ProgressCheckpoint section="level-0" xpReward={10} />

### Level 1: Resources üì¶

**Characteristics:**
- Multiple endpoints (one per resource type)
- Still mostly uses POST
- Beginning to organize around resources

**Example:**
```csharp
[HttpPost("api/users")]
public IActionResult HandleUserRequest([FromBody] UserCommand command)
{
    switch (command.Action)
    {
        case "get":
            return Ok(GetUser(command.Id));
        case "create":
            return Ok(CreateUser(command.Data));
        case "delete":
            return Ok(DeleteUser(command.Id));
    }
}

[HttpPost("api/products")]
public IActionResult HandleProductRequest([FromBody] ProductCommand command)
{
    // Similar pattern for products
}
```

**Request Example:**
```json
POST /api/users
{
  "action": "get",
  "id": 123
}
```

**Improvements:**
- Better organization
- Easier to understand what resources exist
- Can apply different security rules per resource

**Still Missing:**
- Proper HTTP method usage
- Standard status codes
- Caching capabilities

<ProgressCheckpoint section="level-1" xpReward={10} />

### Level 2: HTTP Verbs üéØ

**Characteristics:**
- Uses HTTP methods correctly (GET, POST, PUT, DELETE)
- Returns appropriate status codes (200, 201, 404, 500)
- Leverages HTTP features (caching, idempotency)

**This is where most modern "REST" APIs operate!**

**Example:**
```csharp
[ApiController]
[Route("api/users")]
public class UsersController : ControllerBase
{
    [HttpGet("{id}")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult GetUser(int id)
    {
        var user = _repo.GetUser(id);
        if (user == null)
            return NotFound();
        
        return Ok(user);
    }

    [HttpPost]
    [ProducesResponseType(StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public IActionResult CreateUser([FromBody] CreateUserDto dto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        
        var user = _repo.CreateUser(dto);
        return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
    }

    [HttpPut("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult UpdateUser(int id, [FromBody] UpdateUserDto dto)
    {
        var exists = _repo.UserExists(id);
        if (!exists)
            return NotFound();
        
        _repo.UpdateUser(id, dto);
        return NoContent();
    }

    [HttpDelete("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult DeleteUser(int id)
    {
        var exists = _repo.UserExists(id);
        if (!exists)
            return NotFound();
        
        _repo.DeleteUser(id);
        return NoContent();
    }
}
```

**Request Examples:**
```http
GET    /api/users/123      ‚Üí 200 OK (with user data)
POST   /api/users          ‚Üí 201 Created
PUT    /api/users/123      ‚Üí 204 No Content
DELETE /api/users/123      ‚Üí 204 No Content
GET    /api/users/999      ‚Üí 404 Not Found
```

**Benefits:**
- **Caching:** GET requests can be cached
- **Idempotency:** PUT and DELETE are safe to retry
- **Standard Semantics:** Everyone knows what GET means
- **Tooling Support:** Browsers, proxies, CDNs understand HTTP methods
- **Clear Intent:** Method name indicates operation type

<ProgressCheckpoint section="level-2" xpReward={10} />

### Level 3: Hypermedia Controls (HATEOAS) üîó

**HATEOAS = Hypermedia As The Engine Of Application State**

**The Principle:** The server tells the client what actions are available through hypermedia links.

**The Vision:** Clients don't hardcode URLs or business logic. They discover available actions from the server's responses.

#### Non-HATEOAS Response (Level 2)

```json
{
  "id": 1,
  "name": "Wireless Headphones",
  "price": 199.99,
  "stock": 5,
  "status": "available"
}
```

**Client Logic (Hardcoded):**
```javascript
// Client must know business rules
if (product.stock > 0 && product.status === 'available') {
  showButton('Add to Cart', () => {
    fetch('POST /api/cart/items', { productId: product.id });
  });
}

if (userIsAdmin) {
  showButton('Delete', () => {
    fetch('DELETE /api/products/' + product.id);
  });
}
```

**Problems:**
- Client hardcodes URLs
- Client hardcodes business logic
- Changes require updating all clients
- No discoverability

#### HATEOAS Response (Level 3)

```json
{
  "id": 1,
  "name": "Wireless Headphones",
  "price": 199.99,
  "stock": 5,
  "status": "available",
  "_links": {
    "self": {
      "href": "/api/products/1",
      "method": "GET"
    },
    "add-to-cart": {
      "href": "/api/cart/items",
      "method": "POST",
      "body": { "productId": 1, "quantity": 1 }
    },
    "reviews": {
      "href": "/api/products/1/reviews",
      "method": "GET"
    },
    "similar-products": {
      "href": "/api/products?category=electronics&exclude=1",
      "method": "GET"
    }
  }
}
```

**If the product is out of stock:**
```json
{
  "id": 2,
  "name": "Gaming Mouse",
  "price": 79.99,
  "stock": 0,
  "status": "out-of-stock",
  "_links": {
    "self": {
      "href": "/api/products/2",
      "method": "GET"
    },
    "notify-when-available": {
      "href": "/api/products/2/notifications",
      "method": "POST"
    },
    "similar-products": {
      "href": "/api/products?category=gaming&exclude=2",
      "method": "GET"
    }
  }
}
```

**Client Logic (Generic):**
```javascript
// Client just renders available links
response._links.forEach(link => {
  if (link.rel === 'add-to-cart') {
    showButton('Add to Cart', () => {
      fetch(link.href, {
        method: link.method,
        body: JSON.stringify(link.body)
      });
    });
  }
});
```

**Benefits:**
- **Decoupling:** Client doesn't know URL structure
- **Evolvability:** Server can change URLs without breaking clients
- **Discoverability:** Clients discover capabilities from responses
- **Business Logic on Server:** Server controls what actions are available

<ProgressCheckpoint section="hateoas-concept" xpReward={10} />

## Implementing HATEOAS in ASP.NET Core üõ†Ô∏è

ASP.NET Core doesn't enforce HATEOAS by default, but you can implement it:

### Basic Implementation

```csharp
public class Link
{
    public string Href { get; set; }
    public string Rel { get; set; }
    public string Method { get; set; }
}

public class ResourceBase
{
    public List<Link> Links { get; set; } = new();
}

public class ProductResource : ResourceBase
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
}
```

### Controller with HATEOAS

```csharp
[ApiController]
[Route("api/products")]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _repo;

    [HttpGet("{id}")]
    public IActionResult GetProduct(int id)
    {
        var product = _repo.GetProduct(id);
        if (product == null)
            return NotFound();

        var resource = new ProductResource
        {
            Id = product.Id,
            Name = product.Name,
            Price = product.Price,
            Stock = product.Stock
        };

        // Add self link
        resource.Links.Add(new Link
        {
            Href = Url.Link("GetProduct", new { id }),
            Rel = "self",
            Method = "GET"
        });

        // Add conditional links based on business rules
        if (product.Stock > 0)
        {
            resource.Links.Add(new Link
            {
                Href = Url.Link("AddToCart", null),
                Rel = "add-to-cart",
                Method = "POST"
            });
        }
        else
        {
            resource.Links.Add(new Link
            {
                Href = Url.Link("NotifyWhenAvailable", new { id }),
                Rel = "notify-when-available",
                Method = "POST"
            });
        }

        // Add related resources
        resource.Links.Add(new Link
        {
            Href = Url.Link("GetProductReviews", new { id }),
            Rel = "reviews",
            Method = "GET"
        });

        // Admin-only actions
        if (User.IsInRole("Admin"))
        {
            resource.Links.Add(new Link
            {
                Href = Url.Link("UpdateProduct", new { id }),
                Rel = "update",
                Method = "PUT"
            });

            resource.Links.Add(new Link
            {
                Href = Url.Link("DeleteProduct", new { id }),
                Rel = "delete",
                Method = "DELETE"
            });
        }

        return Ok(resource);
    }
}
```

### Using a Library: HAL (Hypertext Application Language)

```csharp
// Install: dotnet add package Hal.AspNetCore

public class ProductHalResource : Resource
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
}

[HttpGet("{id}")]
public IActionResult GetProduct(int id)
{
    var product = _repo.GetProduct(id);
    if (product == null)
        return NotFound();

    var resource = new ProductHalResource
    {
        Id = product.Id,
        Name = product.Name,
        Price = product.Price,
        Stock = product.Stock
    };

    // HAL automatically adds _links
    resource.AddLink("self", $"/api/products/{id}");
    
    if (product.Stock > 0)
        resource.AddLink("add-to-cart", "/api/cart/items");
    
    resource.AddLink("reviews", $"/api/products/{id}/reviews");

    return Ok(resource);
}
```

<ProgressCheckpoint section="hateoas-implementation" xpReward={10} />

## The HATEOAS Debate: Is It Worth It? ü§î

<KeyConcept title="The Trade-offs of HATEOAS">
  HATEOAS provides maximum decoupling and evolvability, but at the cost of complexity. Most teams find Level 2 REST sufficient for their needs.
</KeyConcept>

### Arguments FOR HATEOAS ‚úÖ

1. **True Decoupling:** Clients don't hardcode URLs
2. **Evolvability:** Change server URLs without breaking clients
3. **Discoverability:** Clients can explore the API dynamically
4. **Business Logic Centralization:** Server controls available actions
5. **Self-Documenting:** Responses show what's possible

### Arguments AGAINST HATEOAS ‚ùå

1. **Complexity:** Significantly more code on both client and server
2. **Performance:** Larger response payloads
3. **Client Burden:** Clients must parse and interpret links
4. **Tooling:** Less tooling support than OpenAPI/Swagger
5. **Overkill:** Most APIs don't need this level of flexibility

### When to Use Each Level

**Level 2 (Most Common):**
- Internal APIs
- Mobile apps (where you control the client)
- Microservices
- APIs with versioning strategy
- When you want OpenAPI/Swagger documentation

**Level 3 (HATEOAS):**
- Public APIs with many unknown clients
- Long-lived APIs (10+ years)
- APIs where business rules change frequently
- When you want maximum evolvability
- Academic or research projects

<InfoBox type="tip">
  **Industry Reality:** Most successful APIs (GitHub, Stripe, Twitter) operate at Level 2. They use versioning and good documentation instead of HATEOAS. Choose the level that matches your needs, not the theoretical ideal.
</InfoBox>

## Real-World Example: GitHub API üåê

GitHub's API is Level 2 with some Level 3 features:

```json
GET /repos/microsoft/dotnet

{
  "id": 123456,
  "name": "dotnet",
  "full_name": "microsoft/dotnet",
  "url": "https://api.github.com/repos/microsoft/dotnet",
  "forks_url": "https://api.github.com/repos/microsoft/dotnet/forks",
  "issues_url": "https://api.github.com/repos/microsoft/dotnet/issues{/number}",
  "pulls_url": "https://api.github.com/repos/microsoft/dotnet/pulls{/number}"
}
```

They include related resource URLs, but clients still need to know the API structure. It's a pragmatic middle ground.

<ProgressCheckpoint section="statelessness" xpReward={50} />
