# Advanced API Versioning: Deprecation, Migration, and Enterprise Patterns

Managing API versions in production requires sophisticated strategies for deprecation, migration, and long-term maintenance. Let's explore enterprise-grade versioning patterns.

## Version Deprecation Strategy üìÖ

### Marking Versions as Deprecated

```csharp
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("1.0", Deprecated = true)]  // Mark as deprecated
[ApiVersion("2.0")]
[ApiVersion("3.0")]
public class UsersController : ControllerBase
{
    [HttpGet]
    [MapToApiVersion("1.0")]
    public IActionResult GetUsersV1()
    {
        // Add deprecation warning to response
        Response.Headers.Add("X-API-Deprecated", "true");
        Response.Headers.Add("X-API-Sunset-Date", "2026-06-01");
        Response.Headers.Add("X-API-Deprecation-Info", "https://docs.myapi.com/migration/v1-to-v2");
        
        return Ok(new[] { new { Id = 1, Name = "John" } });
    }
    
    [HttpGet]
    [MapToApiVersion("2.0")]
    public IActionResult GetUsersV2()
    {
        return Ok(new[] { new { Id = 1, FullName = "John Doe", Email = "john@example.com" } });
    }
}
```

**Response Headers:**
```http
HTTP/1.1 200 OK
X-API-Deprecated: true
X-API-Sunset-Date: 2026-06-01
X-API-Deprecation-Info: https://docs.myapi.com/migration/v1-to-v2
api-deprecated-versions: 1.0
api-supported-versions: 1.0, 2.0, 3.0
```

<ProgressCheckpoint section="deprecation-basics" xpReward={10} />

### Deprecation Timeline

**Industry Standard: 12-18 Month Deprecation Cycle**

```
Month 0: Release v2
‚îú‚îÄ Announce v1 deprecation
‚îú‚îÄ Update documentation
‚îî‚îÄ Add deprecation headers

Month 3: Warning Phase
‚îú‚îÄ Email users still on v1
‚îú‚îÄ Add warning logs
‚îî‚îÄ Provide migration guide

Month 6: Aggressive Warnings
‚îú‚îÄ Add deprecation notices to responses
‚îú‚îÄ Reduce rate limits for v1
‚îî‚îÄ Offer migration support

Month 12: Sunset Announcement
‚îú‚îÄ Final warning emails
‚îú‚îÄ Set sunset date
‚îî‚îÄ Prepare for shutdown

Month 18: Sunset
‚îú‚îÄ v1 returns 410 Gone
‚îî‚îÄ Redirect to v2 documentation
```

### Implementing Sunset Responses

```csharp
public class ApiVersionSunsetMiddleware
{
    private readonly RequestDelegate _next;
    private readonly Dictionary<string, DateTime> _sunsetDates = new()
    {
        { "1.0", new DateTime(2026, 6, 1) }
    };

    public async Task InvokeAsync(HttpContext context)
    {
        var version = context.GetRequestedApiVersion();
        
        if (version != null && _sunsetDates.TryGetValue(version.ToString(), out var sunsetDate))
        {
            if (DateTime.UtcNow >= sunsetDate)
            {
                // Version has been sunset
                context.Response.StatusCode = 410; // Gone
                await context.Response.WriteAsJsonAsync(new
                {
                    error = "API version no longer supported",
                    version = version.ToString(),
                    sunsetDate = sunsetDate,
                    message = "Please upgrade to v2.0",
                    migrationGuide = "https://docs.myapi.com/migration/v1-to-v2"
                });
                return;
            }
            
            // Version is deprecated but still active
            context.Response.Headers.Add("Sunset", sunsetDate.ToString("R"));
            context.Response.Headers.Add("Deprecation", "true");
            context.Response.Headers.Add("Link", "<https://docs.myapi.com/migration/v1-to-v2>; rel=\"deprecation\"");
        }
        
        await _next(context);
    }
}

// Register in Program.cs
app.UseMiddleware<ApiVersionSunsetMiddleware>();
```

<ProgressCheckpoint section="sunset" xpReward={15} />

## Media Type (Content Negotiation) Versioning üé≠

**Pattern:** Version embedded in the `Accept` header (GitHub's approach)

### Why Media Type Versioning?

- Versions representations, not resources
- Follows REST principles strictly
- Allows per-endpoint versioning
- Supports multiple formats (JSON, XML, etc.)

### Implementation

```csharp
// Program.cs
builder.Services.AddApiVersioning(options =>
{
    options.ApiVersionReader = new MediaTypeApiVersionReader("version");
});

// Controller
[ApiController]
[Route("api/[controller]")]
public class RepositoriesController : ControllerBase
{
    [HttpGet("{id}")]
    [Produces("application/vnd.myapp.v1+json", "application/vnd.myapp.v2+json")]
    public IActionResult GetRepository(int id)
    {
        var version = HttpContext.GetRequestedApiVersion();
        
        if (version?.MajorVersion == 1)
        {
            return Ok(new
            {
                Id = id,
                Name = "MyRepo",
                Stars = 100
            });
        }
        
        // v2 with additional fields
        return Ok(new
        {
            Id = id,
            Name = "MyRepo",
            FullName = "user/MyRepo",
            Stars = 100,
            Forks = 25,
            Language = "C#",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        });
    }
}
```

**Client Usage:**
```http
GET /api/repositories/123
Accept: application/vnd.myapp.v1+json
‚Üí Returns v1 format

GET /api/repositories/123
Accept: application/vnd.myapp.v2+json
‚Üí Returns v2 format

GET /api/repositories/123
Accept: application/json
‚Üí Returns latest version (v2)
```

<ProgressCheckpoint section="media-type-versioning" xpReward={15} />

## Semantic Versioning (SemVer) in APIs üìä

**Format:** MAJOR.MINOR.PATCH (e.g., 2.1.3)

### SemVer Rules

- **MAJOR:** Breaking changes (incompatible API changes)
- **MINOR:** New features (backward-compatible)
- **PATCH:** Bug fixes (backward-compatible)

### Applying SemVer to APIs

```csharp
[ApiVersion("2.0")]      // Major version in URL
[ApiVersion("2.1")]      // Minor version (optional)
[ApiVersion("2.1.3")]    // Patch version (rare in URLs)
```

**Best Practice for URL Versioning:**
```csharp
‚úÖ Use MAJOR only in URLs
/api/v1/users
/api/v2/users

‚ùå Avoid MINOR/PATCH in URLs
/api/v2.1/users      // Confusing!
/api/v2.1.3/users    // Too granular!
```

**Best Practice for Header/Query Versioning:**
```csharp
‚úÖ Can use MAJOR.MINOR
?api-version=2.1
X-API-Version: 2.1

‚úÖ PATCH versions are implicit
2.1.0 ‚Üí 2.1.3 (bug fixes, no version change needed)
```

### Implementation

```csharp
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("2.0")]
[ApiVersion("2.1")]  // Added new features
[ApiVersion("2.2")]  // Added more features
public class ProductsController : ControllerBase
{
    // Available in all versions
    [HttpGet]
    public IActionResult GetProducts()
    {
        return Ok(GetProductsData());
    }
    
    // Added in v2.1
    [HttpGet("featured")]
    [MapToApiVersion("2.1")]
    [MapToApiVersion("2.2")]
    public IActionResult GetFeaturedProducts()
    {
        return Ok(GetFeaturedData());
    }
    
    // Added in v2.2
    [HttpGet("recommendations")]
    [MapToApiVersion("2.2")]
    public IActionResult GetRecommendations()
    {
        return Ok(GetRecommendationsData());
    }
}
```

**Usage:**
```http
GET /api/v2/products              ‚Üí Works (base functionality)
GET /api/v2/products/featured     ‚Üí 404 (not available in 2.0)

GET /api/v2.1/products            ‚Üí Works
GET /api/v2.1/products/featured   ‚Üí Works (added in 2.1)
GET /api/v2.1/products/recommendations ‚Üí 404 (not available until 2.2)

GET /api/v2.2/products            ‚Üí Works
GET /api/v2.2/products/featured   ‚Üí Works
GET /api/v2.2/products/recommendations ‚Üí Works (added in 2.2)
```

<ProgressCheckpoint section="semver" xpReward={15} />

## Version Migration Patterns üîÑ

### Pattern 1: Adapter Pattern

**Problem:** Don't want to duplicate business logic across versions.

**Solution:** Use adapters to transform between versions.

```csharp
// Domain model (version-agnostic)
public class User
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Email { get; set; }
    public DateTime CreatedAt { get; set; }
}

// V1 DTO
public class UserV1Dto
{
    public int Id { get; set; }
    public string Name { get; set; }  // Combined name
}

// V2 DTO
public class UserV2Dto
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Email { get; set; }
    public DateTime CreatedAt { get; set; }
}

// Adapters
public static class UserAdapters
{
    public static UserV1Dto ToV1(User user)
    {
        return new UserV1Dto
        {
            Id = user.Id,
            Name = $"{user.FirstName} {user.LastName}"
        };
    }
    
    public static UserV2Dto ToV2(User user)
    {
        return new UserV2Dto
        {
            Id = user.Id,
            FirstName = user.FirstName,
            LastName = user.LastName,
            Email = user.Email,
            CreatedAt = user.CreatedAt
        };
    }
}

// Controller
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;
    
    [HttpGet("{id}")]
    [MapToApiVersion("1.0")]
    public IActionResult GetUserV1(int id)
    {
        var user = _userService.GetById(id);  // Single source of truth
        return Ok(UserAdapters.ToV1(user));
    }
    
    [HttpGet("{id}")]
    [MapToApiVersion("2.0")]
    public IActionResult GetUserV2(int id)
    {
        var user = _userService.GetById(id);  // Same business logic
        return Ok(UserAdapters.ToV2(user));
    }
}
```

<ProgressCheckpoint section="adapter-pattern" xpReward={15} />

### Pattern 2: Feature Flags for Gradual Rollout

```csharp
public class FeatureFlagVersioningMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IFeatureFlagService _featureFlags;

    public async Task InvokeAsync(HttpContext context)
    {
        var version = context.GetRequestedApiVersion();
        var userId = context.User.GetUserId();
        
        // Check if user is in v2 beta
        if (version?.MajorVersion == 2)
        {
            var hasV2Access = await _featureFlags.IsEnabledAsync("api-v2", userId);
            
            if (!hasV2Access)
            {
                context.Response.StatusCode = 403;
                await context.Response.WriteAsJsonAsync(new
                {
                    error = "API v2 is currently in beta",
                    message = "Contact support to join the beta program"
                });
                return;
            }
        }
        
        await _next(context);
    }
}
```

<ProgressCheckpoint section="feature-flags" xpReward={10} />

## Monitoring and Analytics üìä

### Track Version Usage

```csharp
public class ApiVersionTelemetryMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ApiVersionTelemetryMiddleware> _logger;
    private readonly IMetricsService _metrics;

    public async Task InvokeAsync(HttpContext context)
    {
        var version = context.GetRequestedApiVersion();
        var endpoint = context.GetEndpoint()?.DisplayName;
        
        // Log version usage
        _logger.LogInformation(
            "API Request: Version={Version}, Endpoint={Endpoint}, User={User}",
            version,
            endpoint,
            context.User.Identity?.Name
        );
        
        // Track metrics
        _metrics.IncrementCounter("api_requests_total", new Dictionary<string, string>
        {
            { "version", version?.ToString() ?? "unspecified" },
            { "endpoint", endpoint ?? "unknown" }
        });
        
        await _next(context);
    }
}
```

### Dashboard Queries

```sql
-- Users still on v1
SELECT user_id, COUNT(*) as request_count
FROM api_logs
WHERE version = '1.0'
  AND timestamp > NOW() - INTERVAL '7 days'
GROUP BY user_id
ORDER BY request_count DESC;

-- Version adoption over time
SELECT 
    DATE(timestamp) as date,
    version,
    COUNT(*) as requests
FROM api_logs
WHERE timestamp > NOW() - INTERVAL '30 days'
GROUP BY DATE(timestamp), version
ORDER BY date, version;
```

<ProgressCheckpoint section="monitoring" xpReward={10} />

## The Golden Rules of API Versioning üìú

<KeyConcept title="Never Break the Contract">
  Once an API version is public, **NEVER** change its behavior. If you need different behavior, create a new version. Breaking changes destroy trust and break production systems.
</KeyConcept>

### Rule 1: Immutability

```csharp
‚ùå NEVER DO THIS:
// v1 initially returned { "name": "John" }
// Later changed to { "fullName": "John" }  ‚Üê BREAKS CLIENTS!

‚úÖ DO THIS:
// v1 always returns { "name": "John" }
// v2 returns { "fullName": "John" }
```

### Rule 2: Backward Compatibility

```csharp
‚úÖ Safe changes (don't need new version):
- Adding optional fields
- Adding new endpoints
- Bug fixes
- Performance improvements

‚ùå Breaking changes (need new version):
- Removing fields
- Renaming fields
- Changing data types
- Changing behavior
- Adding required parameters
```

### Rule 3: Support Multiple Versions

```csharp
// Support at least 2 versions simultaneously
‚úÖ v1 (stable) + v2 (current)
‚úÖ v2 (stable) + v3 (current) + v1 (deprecated)

‚ùå Only v2 (breaks v1 users immediately)
```

### Rule 4: Communicate Changes

```csharp
// Always provide:
1. Migration guide
2. Deprecation timeline
3. Breaking changes list
4. Code examples
5. Support contact
```

### Rule 5: Version Everything

```csharp
‚úÖ Version from day one
/api/v1/users  (not /api/users)

‚úÖ Version DTOs
public class UserV1Dto { }
public class UserV2Dto { }

‚úÖ Version documentation
docs/api/v1/
docs/api/v2/
```

<ProgressCheckpoint section="aspnet-implementation" xpReward={50} />
