# API Routing Deep Dive

ASP.NET Core uses **attribute routing** for Web APIs, where routes are defined using attributes directly on controllers and actions. This provides explicit, maintainable route definitions.

## Section 1: Route Template Syntax

<RoutingAttributeExplorer mode="intermediate" />

### Route Tokens

Special tokens get replaced at runtime:

| Token | Replacement |
| :---- | :---------- |
| `[controller]` | Controller name minus "Controller" suffix |
| `[action]` | Action method name |
| `[area]` | Area name (if using areas) |

```csharp
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    // Route becomes: api/products
    
    [HttpGet("[action]")]  // GET /api/products/featured
    public ActionResult<List<Product>> Featured() { }
}
```

### Route Parameters

```csharp
// Required parameter
[HttpGet("{id}")]
public ActionResult<Product> GetById(int id) { }

// Optional parameter
[HttpGet("{id?}")]
public ActionResult GetById(int? id) { }

// Default value
[HttpGet("{page=1}")]
public ActionResult<List<Product>> GetAll(int page) { }
```

<ProgressCheckpoint section="routing-intro" xpReward={13} />

---

## Section 2: Route Constraints

### Constraining Parameter Types

```csharp
// Only matches integer IDs
[HttpGet("{id:int}")]
public ActionResult<Product> GetById(int id) { }

// Only matches GUIDs
[HttpGet("{id:guid}")]
public ActionResult<Product> GetByGuid(Guid id) { }

// Minimum value constraint
[HttpGet("{id:int:min(1)}")]
public ActionResult<Product> GetById(int id) { }


// Regex constraint
[HttpGet("{slug:regex(^[a-z0-9-]+$)}")]
public ActionResult<Product> GetBySlug(string slug) { }
```

### Common Constraints

| Constraint | Description | Example |
| :--------- | :---------- | :------ |
| `int` | Integer | `{id:int}` |
| `guid` | GUID format | `{id:guid}` |
| `min(n)` | Minimum value | `{id:min(1)}` |
| `max(n)` | Maximum value | `{id:max(100)}` |
| `length(n)` | Exact length | `{code:length(6)}` |
| `alpha` | Letters only | `{name:alpha}` |
| `required` | Must have value | `{name:required}` |

<ProgressCheckpoint section="routing-intermediate" xpReward={13} />

---

## Section 3: Query Parameters and Multiple Routes

### Query String Parameters

Parameters not in the route come from query string:

```csharp
// GET /api/products?category=electronics&minPrice=100
[HttpGet]
public ActionResult<List<Product>> Search(
    string? category,
    decimal? minPrice,
    decimal? maxPrice,
    int page = 1,
    int pageSize = 10)
{
    return Ok(_service.Search(category, minPrice, maxPrice, page, pageSize));
}
```

### Multiple Routes for One Action

Actions can have multiple routes:

```csharp
[HttpGet]
[Route("")]           // /api/products
[Route("all")]        // /api/products/all
[Route("~/products")] // /products (absolute, ignores controller route)
public ActionResult<List<Product>> GetAll() { }
```

### Combining Route and Query Parameters

```csharp
// GET /api/products/category/electronics?page=2&sort=price
[HttpGet("category/{categoryName}")]
public ActionResult<PagedResult<Product>> GetByCategory(
    string categoryName,
    int page = 1,
    string sort = "name")
{
    return Ok(_service.GetByCategory(categoryName, page, sort));
}
```

### Best Practices

1. **Use constraints** to validate route parameters early
2. **Prefer route parameters** for required identifiers
3. **Use query parameters** for optional filters and pagination
4. **Keep routes RESTful** and predictable

<ProgressCheckpoint section="routing-advanced" xpReward={14} />
