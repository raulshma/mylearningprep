# Advanced Model Binding & Validation

Master custom binders, complex validation scenarios, and enterprise-grade validation patterns.

## Section 1: Custom Model Binders

<ModelBindingVisualizer mode="advanced" />

### Creating a Custom Binder

```csharp
// Custom binder for comma-separated values
public class CommaSeparatedModelBinder : IModelBinder
{
    public Task BindModelAsync(ModelBindingContext bindingContext)
    {
        var valueProviderResult = bindingContext.ValueProvider
            .GetValue(bindingContext.ModelName);

        if (valueProviderResult == ValueProviderResult.None)
            return Task.CompletedTask;

        var value = valueProviderResult.FirstValue;
        if (string.IsNullOrEmpty(value))
            return Task.CompletedTask;

        var result = value.Split(',')
            .Select(int.Parse)
            .ToList();

        bindingContext.Result = ModelBindingResult.Success(result);
        return Task.CompletedTask;
    }
}

// Provider
public class CommaSeparatedModelBinderProvider : IModelBinderProvider
{
    public IModelBinder? GetBinder(ModelBinderProviderContext context)
    {
        if (context.Metadata.ModelType == typeof(List<int>) &&
            context.BindingInfo.BindingSource == BindingSource.Query)
        {
            return new CommaSeparatedModelBinder();
        }
        return null;
    }
}

// Register in Program.cs
builder.Services.AddControllers(options =>
{
    options.ModelBinderProviders.Insert(0, new CommaSeparatedModelBinderProvider());
});

// Usage: GET /api/products?ids=1,2,3,4
[HttpGet]
public ActionResult GetMany([FromQuery] List<int> ids) { }
```

<ProgressCheckpoint section="model-binding-intro" xpReward={16} />

---

## Section 2: IValidatableObject and Custom Attributes

### Cross-Property Validation


```csharp
public class DateRangeDto : IValidatableObject
{
    [Required]
    public DateTime StartDate { get; set; }

    [Required]
    public DateTime EndDate { get; set; }

    public IEnumerable<ValidationResult> Validate(
        ValidationContext validationContext)
    {
        if (EndDate < StartDate)
        {
            yield return new ValidationResult(
                "End date must be after start date",
                new[] { nameof(EndDate) });
        }

        if ((EndDate - StartDate).TotalDays > 365)
        {
            yield return new ValidationResult(
                "Date range cannot exceed one year",
                new[] { nameof(StartDate), nameof(EndDate) });
        }
    }
}
```

### Custom Validation Attributes

```csharp
[AttributeUsage(AttributeTargets.Property)]
public class FutureDateAttribute : ValidationAttribute
{
    protected override ValidationResult? IsValid(
        object? value,
        ValidationContext validationContext)
    {
        if (value is DateTime date && date <= DateTime.Today)
        {
            return new ValidationResult(
                ErrorMessage ?? "Date must be in the future");
        }
        return ValidationResult.Success;
    }
}

// Usage
public class AppointmentDto
{
    [Required]
    [FutureDate(ErrorMessage = "Appointment must be in the future")]
    public DateTime AppointmentDate { get; set; }
}
```

<ProgressCheckpoint section="model-binding-intermediate" xpReward={16} />

---

## Section 3: FluentValidation and Global Error Handling

### FluentValidation Integration

```csharp
// Install: dotnet add package FluentValidation.AspNetCore

public class CreateOrderValidator : AbstractValidator<CreateOrderRequest>
{
    public CreateOrderValidator(ICustomerService customerService)
    {
        RuleFor(x => x.CustomerId)
            .MustAsync(async (id, ct) =>
                await customerService.ExistsAsync(id))
            .WithMessage("Customer does not exist");

        RuleFor(x => x.Items)
            .NotEmpty()
            .WithMessage("Order must have at least one item");

        RuleForEach(x => x.Items).ChildRules(item =>
        {
            item.RuleFor(x => x.Quantity).GreaterThan(0);
            item.RuleFor(x => x.UnitPrice).GreaterThan(0);
        });
    }
}

// Register
builder.Services.AddValidatorsFromAssemblyContaining<CreateOrderValidator>();
builder.Services.AddFluentValidationAutoValidation();
```

### Global Error Response Customization

```csharp
builder.Services.AddControllers()
    .ConfigureApiBehaviorOptions(options =>
    {
        options.InvalidModelStateResponseFactory = context =>
        {
            var errors = context.ModelState
                .Where(e => e.Value?.Errors.Count > 0)
                .ToDictionary(
                    e => e.Key,
                    e => e.Value!.Errors.Select(x => x.ErrorMessage).ToArray());

            var response = new
            {
                Success = false,
                Message = "Validation failed",
                Errors = errors,
                TraceId = context.HttpContext.TraceIdentifier
            };

            return new BadRequestObjectResult(response);
        };
    });
```

### Best Practices Summary

| Pattern | Use Case |
| :------ | :------- |
| **Data Annotations** | Simple property validation |
| **IValidatableObject** | Cross-property validation |
| **Custom Attributes** | Reusable validation rules |
| **FluentValidation** | Complex business rules |
| **Custom Binders** | Special data formats |

<ProgressCheckpoint section="model-binding-advanced" xpReward={18} />
