# Response Formatting in Depth

ASP.NET Core uses **content negotiation** to determine response format based on the client's `Accept` header. Understanding formatters and action results gives you full control over API responses.

## Section 1: Content Negotiation

<ResponseFormattingDemo mode="intermediate" />

### The Process

1. Client sends `Accept: application/json` header
2. Server checks available output formatters
3. Server selects matching formatter
4. Data is serialized in requested format

### Configuring JSON Serialization

```csharp
builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        // Use camelCase (default)
        options.JsonSerializerOptions.PropertyNamingPolicy =
            JsonNamingPolicy.CamelCase;

        // Pretty print
        options.JsonSerializerOptions.WriteIndented = true;

        // Handle null values
        options.JsonSerializerOptions.DefaultIgnoreCondition =
            JsonIgnoreCondition.WhenWritingNull;

        // Handle enums as strings
        options.JsonSerializerOptions.Converters.Add(
            new JsonStringEnumConverter());
    });
```

<ProgressCheckpoint section="response-formatting-intro" xpReward={13} />

---

## Section 2: Action Results and Problem Details

### Choosing the Right Result

```csharp
// Return data with 200 OK
[HttpGet("{id}")]
public ActionResult<Product> GetById(int id)
{
    var product = _service.GetById(id);
    return product is null ? NotFound() : Ok(product);
}

// Return created resource with location header
[HttpPost]
public ActionResult<Product> Create(Product product)
{
    _service.Add(product);
    return CreatedAtAction(
        nameof(GetById),
        new { id = product.Id },
        product);
}

// Return no content for updates
[HttpPut("{id}")]
public ActionResult Update(int id, Product product)
{
    _service.Update(id, product);
    return NoContent();
}
```


### Problem Details (RFC 7807)

Standardized error response format:

```csharp
[HttpGet("{id}")]
public ActionResult GetById(int id)
{
    if (id < 0)
    {
        return Problem(
            title: "Invalid ID",
            detail: "ID must be a positive integer",
            statusCode: 400,
            instance: HttpContext.Request.Path
        );
    }
    // ...
}
```

Response:

```json
{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "Invalid ID",
  "status": 400,
  "detail": "ID must be a positive integer",
  "instance": "/api/products/-1"
}
```

<ProgressCheckpoint section="response-formatting-intermediate" xpReward={13} />

---

## Section 3: XML Support and Custom Headers

### Adding XML Support

```csharp
builder.Services.AddControllers()
    .AddXmlSerializerFormatters();
```

```csharp
// Force specific format
[HttpGet]
[Produces("application/xml")]
public ActionResult<List<Product>> GetAllXml() { }

// Support multiple formats
[HttpGet]
[Produces("application/json", "application/xml")]
public ActionResult<List<Product>> GetAll() { }
```

### Custom Response Headers

```csharp
[HttpGet]
public ActionResult<List<Product>> GetAll(int page = 1, int pageSize = 10)
{
    var result = _service.GetPaged(page, pageSize);

    Response.Headers.Add("X-Total-Count", result.TotalCount.ToString());
    Response.Headers.Add("X-Page", page.ToString());
    Response.Headers.Add("X-Page-Size", pageSize.ToString());

    return Ok(result.Items);
}
```

### Best Practices

1. **Use consistent status codes** across your API
2. **Return Problem Details** for errors
3. **Include pagination headers** for list endpoints
4. **Configure JSON serialization** globally
5. **Support content negotiation** when needed

<ProgressCheckpoint section="response-formatting-advanced" xpReward={14} />
